\documentclass{article}
\usepackage{csquotes}
\usepackage[utf8x]{inputenc}
\usepackage[T1,T2A]{fontenc}
\usepackage{fvextra}
\fvset{commandchars=\\\{\}, mathescape=true}
\usepackage{xcolor}
\usepackage{amssymb}       % define \Sha
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage[style=ieee]{biblatex} % Establecer el estilo de las referencias como IEEE
\usepackage{hyperref}
\usepackage{titletoc}
\usepackage{adjustbox}

\definecolor{bg}{rgb}{0.95,0.95,0.95}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{purple}{rgb}{0.58,0,0.82}
\definecolor{bluekeyword}{rgb}{0.26,0.44,0.76}
\definecolor{lightorange}{rgb}{0.8,0.5,0.2}
\definecolor{darkgreen}{rgb}{0.0,0.5,0.0}

\lstdefinestyle{mypython}{
    inputencoding=utf8,           % Indica a listings que use UTF-8
    extendedchars=true,           % Permite caracteres extendidos
    mathescape=true,              % Habilita modo matemático dentro de literales
    language=Python,
    backgroundcolor=\color{bg},
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{bluekeyword}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{lightorange},
    numberstyle=\tiny\color{gray},
    identifierstyle=\color{black},
    showstringspaces=false,
    numbers=left,
    numbersep=10pt,
    frame=single,
    breaklines=true,
    tabsize=4,
    captionpos=b,
    escapeinside={(*@}{@*)},
    literate=
     {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
     {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
     {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {π}{{$\pi$}}1  {Ш}{{\fontencoding{T2A}\selectfont\char"DB}}1
     {¡}{{\textexclamdown}}1 {¿}{{\textquestiondown}}1
}


\hypersetup{
    colorlinks=true,
    linkcolor=blue, % Color del texto del enlace
    urlcolor=blue % Color del enlace
}

\usepackage{longtable} % Agrega el paquete longtable

\definecolor{mygreen}{RGB}{0,128,0}

\usepackage{array} % Para personalizar la tabla
\usepackage{booktabs} % Para líneas horizontales de mejor calidad
\usepackage{graphicx} % Paquete para incluir imágenes
\usepackage{float}
\usepackage[section]{placeins}

% Definir márgenes
\usepackage[margin=1in]{geometry}

\renewcommand{\contentsname}{\textcolor{mygreen}{Tabla de Contenidos}}

\begin{document}

\begin{titlepage}
  \centering
  % Logo de la Universidad
  \includegraphics[width=0.48\textwidth]{logo_universidad.png}
  \par\vspace{2cm}

  % Nombre de la Universidad y detalles del curso
  {\Large \textbf{Universidad Nacional de Colombia} \par}
  \vspace{0.5cm}
  {\large Ingeniería de Sistemas y Computación \par}
  {\large 2025966 Lenguajes de Programación (02)\par}
  \vspace{3cm}

  % Detalles del laboratorio y actividad
  {\large \textbf{Taller 2} \par}
  {\large Analizador Sintáctico y Semántico\par}
  \vspace{3cm}

  % Lista de integrantes
  {\large \textbf{Integrantes:} \par}
  \vspace{0.5cm}
  \begin{tabular}{ll}
    Javier Andrés Tarazona Jiménez   & jtarazonaj@unal.edu.co \\
    David Felipe Marin Rosas         & dmarinro@unal.edu.co   \\
    Juan Sebastian Muñoz Lemus       & jumunozle@unal.edu.co          \\
    Eder José Hernández Buelvas      & ehernandezbu@unal.edu.co          \\
    Axel Gomez Moreno                & axgomezm@unal.edu.co          \\
    Daniel Santiago Delgado Pinilla  & ddelgadopi@unal.edu.co          \\
  \end{tabular}
  \par\vspace{3cm}

  % Fecha
  {\large Junio 24 de 2025 \par}
\end{titlepage}

\tableofcontents % Inserta la tabla de contenidos

\newpage % Salto de página para separar la tabla de contenidos del contenido del documento

% Contenido del artículo----------------------------------------------------------

%---------------------------------------------------------------------------------
% Intro --------------------------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Introducción}\label{sec:intr}

En la actualidad, el análisis estadístico desempeña un papel fundamental en la toma de decisiones dentro de diversos campos de la investigación científica y aplicada. La correcta interpretación de datos experimentales, especialmente aquellos organizados en estructuras de clasificación de dos vías, requiere herramientas especializadas que permitan automatizar cálculos complejos y minimizar el margen de error humano.

El presente trabajo tiene como objetivo principal el diseño y construcción de un lenguaje de programación de propósito específico, enfocado en la aplicación de pruebas estadísticas de tipo Friedman y en el análisis de rachas, facilitando la ejecución de procedimientos estadísticos robustos. Este lenguaje se desarrollará bajo el paradigma imperativo, incorporando estructuras de control básicas y soporte para tipos de datos abstractos como variables, arreglos y matrices.

Para lograr este propósito, se propone una solución integral que abarca desde la definición formal de la gramática del lenguaje en notación E-BNF, el diseño de diagramas de sintaxis, la descripción semántica de cada producción, hasta la implementación práctica del compilador utilizando herramientas como FLEX para el análisis léxico y YACC para el análisis sintáctico y la ejecución de acciones semánticas.

Este proyecto no solo contribuye a resolver una necesidad específica del ámbito estadístico, sino que también permite a los estudiantes afianzar sus conocimientos en teoría de lenguajes, compiladores y programación, integrando aspectos teóricos y prácticos en un caso de aplicación real.
%---------------------------------------------------------------------------------
% Marco Teórico ------------------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Marco Teórico}

\subsection*{Lenguajes de Programación de Propósito Específico}

Los lenguajes de programación de propósito específico (DSL, por sus siglas en inglés: \textit{Domain Specific Language}) son lenguajes diseñados para resolver problemas particulares dentro de un dominio limitado de aplicación. A diferencia de los lenguajes de propósito general (GPL), que ofrecen herramientas amplias para múltiples tipos de problemas, los DSL permiten expresar soluciones de manera más directa y eficiente dentro de un campo de especialidad. En el contexto del presente taller, se propone el diseño de un lenguaje de propósito específico orientado al análisis estadístico de dos vías de clasificación, haciendo uso de conceptos como las rachas y las pruebas estadísticas de Friedman.

\subsection*{Clasificación de Dos Vías y Pruebas de Friedman}

La clasificación de dos vías es una técnica estadística utilizada para analizar datos que pueden organizarse en una tabla de doble entrada, considerando dos factores de clasificación. Esta metodología es frecuente en el diseño de experimentos y el análisis no paramétrico, donde se evalúa la influencia de dos factores independientes sobre una variable de respuesta.

Dentro de este marco, la prueba de Friedman es una prueba no paramétrica empleada para detectar diferencias significativas entre grupos relacionados. Es especialmente útil como alternativa a la prueba ANOVA de medidas repetidas, cuando no se cumplen los supuestos de normalidad o igualdad de varianzas. La prueba de Friedman se basa en la clasificación de las observaciones y el cálculo de estadísticos de rachas y rangos para establecer la significancia de las diferencias encontradas.

\subsection*{Concepto de Rachas}

El análisis de rachas es un procedimiento estadístico que evalúa la secuencia de datos para identificar patrones de agrupamiento o alternancia. Una racha se define como una sucesión de resultados similares dentro de una secuencia. Por ejemplo, en una serie de clasificaciones o rangos, las rachas permiten identificar tendencias sistemáticas o aleatoriedad. Este concepto es relevante para validar la independencia de las observaciones o para detectar sesgos en la clasificación de datos.

\subsection*{Gramáticas Libres de Contexto (GLC) y Notación E-BNF}

El diseño de lenguajes de programación requiere la definición formal de su sintaxis mediante gramáticas formales. En este taller se propone el uso de gramáticas libres de contexto (GLC) expresadas en notación E-BNF (\textit{Extended Backus-Naur Form}). Esta notación extiende la notación BNF tradicional para describir de forma más legible y compacta estructuras repetitivas, opciones y secuencias dentro de una gramática.

Una GLC está compuesta por:
\begin{itemize}
    \item Un conjunto finito de símbolos terminales (tokens).
    \item Un conjunto finito de símbolos no terminales.
    \item Un símbolo de inicio.
    \item Un conjunto finito de reglas de producción que definen cómo los símbolos no terminales pueden ser reemplazados por secuencias de símbolos terminales y no terminales.
\end{itemize}

\subsection*{Análisis Léxico y Sintáctico}

El análisis léxico corresponde a la fase del compilador responsable de dividir el texto fuente en tokens significativos, eliminando espacios en blanco y comentarios. En este taller, se hará uso de la herramienta \texttt{FLEX} para construir el analizador léxico. 

El análisis sintáctico, por su parte, valida que la secuencia de tokens se ajuste a las reglas definidas por la gramática, construyendo un árbol de derivación o árbol sintáctico. Para este fin se utilizará \texttt{YACC}, una herramienta para generar analizadores sintácticos basados en gramáticas libres de contexto.

\subsection*{Semántica y Acciones Asociadas}

Además de la sintaxis, un lenguaje de programación requiere definir el significado de sus construcciones. La semántica describe el comportamiento interno del compilador o intérprete al reconocer patrones sintácticos específicos. En este proyecto, se describirá la semántica de cada producción mediante acciones en lenguaje natural y se diseñará su estructura en diagramas UML.

\subsection*{Estructuras de Control y Tipos de Datos Abstractos}

El lenguaje propuesto debe soportar estructuras básicas del paradigma imperativo: secuencia, selección (estructuras condicionales) e iteración (bucles). Asimismo, debe permitir la definición y manipulación de variables, arreglos y matrices como tipos de datos abstractos que faciliten la implementación de procedimientos estadísticos complejos.

\subsection*{Implementación en YACC}

Finalmente, la implementación se realizará mediante \texttt{YACC} (Yet Another Compiler Compiler) o su equivalente en Java o Python. Esto permitirá no solo verificar la validez sintáctica de los programas escritos en el nuevo lenguaje, sino también ejecutar las acciones semánticas requeridas para procesar datos estadísticos y producir resultados coherentes con los métodos de clasificación de dos vías y pruebas de Friedman.

\subsection*{Pruebas y Validación}

Como parte del proceso de validación, se desarrollarán programas de prueba que demuestren la cobertura y robustez de la gramática diseñada, así como la correcta implementación de sus acciones semánticas. Las pruebas de escritorio verificarán que los programas sean aceptados por el compilador y produzcan los resultados esperados.


%---------------------------------------------------------------------------------
% Descripción y Justificación del Problema a Resolver ----------------------------
%---------------------------------------------------------------------------------

\section{Descripción y Justificación del Problema a Resolver}\label{sec:descr}

\section*{Descripción del Problema}

El problema planteado consiste en apoyar a un profesional del campo de la estadística matemática en el diseño y construcción de un lenguaje de programación de propósito específico, orientado a facilitar el análisis de datos mediante la técnica de clasificación de dos vías y la aplicación de pruebas estadísticas del tipo Friedman. 

El lenguaje debe construirse bajo el paradigma imperativo, integrando estructuras de control básicas como secuencia, selección e iteración. Además, debe permitir la definición y manipulación de variables, arreglos y matrices, elementos esenciales para el tratamiento de grandes volúmenes de datos estadísticos. 

Se requiere diseñar una gramática libre de contexto (GLC) en notación E-BNF que describa de forma clara y completa la sintaxis del lenguaje, así como desarrollar los diagramas de sintaxis correspondientes. Igualmente, se debe detallar la interpretación semántica de cada producción de la gramática y plasmarla en diagramas UML, asegurando una implementación coherente mediante el uso de YACC (o sus equivalentes en Java o Python).  

Finalmente, se deben construir casos de prueba representativos para validar el correcto funcionamiento del lenguaje, tanto en su fase de análisis sintáctico como en la ejecución de las acciones semánticas.

\section*{Justificación}

El desarrollo de un lenguaje de propósito específico enfocado en el análisis estadístico de dos vías y pruebas de Friedman surge de la necesidad de automatizar procesos estadísticos repetitivos y complejos que, realizados manualmente, resultan propensos a errores y demandan un alto consumo de tiempo y recursos.

Al contar con un lenguaje adaptado a las particularidades de este campo, se facilita la tarea de los investigadores y analistas estadísticos, permitiéndoles escribir programas que describan de forma directa sus experimentos y análisis, sin necesidad de recurrir a lenguajes de propósito general que requieren más tiempo de desarrollo y validación.

Asimismo, este proyecto fortalece las competencias de los estudiantes en la construcción de compiladores, abarcando desde el diseño de gramáticas libres de contexto hasta la implementación de analizadores léxicos y sintácticos, integrando conocimientos de teoría de lenguajes, análisis léxico y semántico, y automatización de tareas mediante herramientas como FLEX y YACC.

%---------------------------------------------------------------------------------
% Diseño de la solución ---------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Diseño de la solución}\label{sec:dis}


%---------------------------------------------------------------------------------
% Código Fuente ---------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Código Fuente}\label{sec:cod}

El código fuente completo de este modelo se encuentra adjunto como 
(taller2.zip)
y disponible en el repositorio GitHub del proyecto:

\begin{center}
\url{https://github.com/JavierTarazona06/LP02_Tareas/tree/main/taller2/code}
\end{center}

%---------------------------------------------------------------------------------
% Manual Usuario ---------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Manual Usuario}\label{sec:man_u}

El primer paso es descargar el archivo \texttt{taller1.zip}.

El repositorio contiene:
\begin{itemize}
  \item \textbf{Código principal}
  \begin{description}
    \item[\texttt{a\_lexico.py}] Código principal del analizador léxico: 
      define la lista de tokens, patrones (regex) y funciones \texttt{t\_…} que definen patrones
      para cada categoría, y construye el lexer con PLY.
  \end{description}

  \item \textbf{Otros}
  \begin{description}
    \item[\texttt{InstallationGuide.md}] Guía paso a paso (Markdown) para crear y 
      activar el entorno virtual y luego instalar las dependencias necesarias con 
      \texttt{pip install -r requirements.txt}.
    \item[\texttt{requirements.txt}] Lista de dependencias del proyecto 
      (principalmente la versión de \texttt{ply} necesaria para ejecutar el analizador).
  \end{description}

  \item \textbf{Testing}
  \begin{description}
    \item[\texttt{tests/prototype1.txt}] Primer caso de prueba...
  \end{description}
\end{itemize}


Una vez descargado, descomprímalo y acceda a la carpeta. Dentro de ella, cree un 
entorno virtual utilizando Python 3.10. o superior. Para ello, ejecute el siguiente 
comando en 
la terminal o línea de comandos:

\begin{itemize}
  \item En Windows:
        \begin{verbatim}
    python3.12 -m venv nombre_del_entorno
  \end{verbatim}
  \item En macOS o Linux:
        \begin{verbatim}
    python3.12 -m venv nombre_del_entorno
  \end{verbatim}
\end{itemize}

Donde \texttt{nombre\_del\_entorno} es el nombre que desea asignar a su entorno virtual.
A continuación, active el entorno virtual:

\begin{itemize}
  \item En Windows:
        \begin{verbatim}
    .\nombre_del_entorno\Scripts\activate
  \end{verbatim}
  \item En macOS o Linux:
        \begin{verbatim}
    source nombre_del_entorno/bin/activate
  \end{verbatim}
\end{itemize}

Asegúrese de tener el entorno virtual activado. 
A continuación, descargue las dependencias necesarias 
(en este caso, únicamente \texttt{PLY} para gestionar \texttt{Lex}):

\begin{verbatim}
    pip install -r requirements.txt
\end{verbatim}

Una vez activo y el entorno instalado, puede ejecutar el archivo 
principal con el siguiente comando:

\begin{center}
  \begin{adjustbox}{minipage=\linewidth, center}
  \begin{verbatim}
    python a_lexico.py
  \end{verbatim}
  \end{adjustbox}
\end{center}


%---------------------------------------------------------------------------------
% Manual Técnico ---------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Manual Técnico}\label{sec:man_t}


\section{Experimentación}\label{sec:exp}

\subsection{Análisis de resultados}

\subsubsection{Escenario 1: Código correcto completo}



\subsubsection{Escenario 2: Código con errores léxicos}


\subsubsection{Escenario 3:  Anidamientos Complejos }



\section{Conclusiones}

\begin{itemize}
    \item La construcción de un lenguaje de propósito específico orientado a la estadística permite optimizar procesos de análisis de datos, reduciendo tiempos y minimizando errores humanos.
    
    \item El diseño de una gramática libre de contexto, acompañado de diagramas de sintaxis y UML, proporciona una base sólida para la implementación de compiladores eficientes y mantenibles.
    
    \item La integración de herramientas como FLEX y YACC en la construcción del compilador refuerza habilidades prácticas en el desarrollo de analizadores léxicos y sintácticos, permitiendo validar la coherencia entre la sintaxis y la semántica del lenguaje propuesto.
    
    \item La elaboración de casos de prueba complejos garantiza que el lenguaje diseñado es funcional, robusto y capaz de resolver problemas reales en el ámbito de la estadística matemática.
\end{itemize}


\section{Gramáticas}\label{sec:grammar}

A continuación se describen los análisis sintácticos por categorías:

\subsection{Definiciones Generales}

\subsubsection*{Programa}

\begin{verbatim}
program ::= ('COMMENT' | func_declaration)* main_declaration
\end{verbatim}

Define la estructura general de un programa válido en el lenguaje. 
Permite que haya cualquier cantidad de comentarios y llamadas
definiciones de funciones (func\_call) al inicio, 
pero siempre debe finalizar con una llamada a la función principal 
(main\_call).

\subsubsection*{Main Call}

\begin{verbatim}
main_declaration
  ::= 'PALABCLAVE=Func' 
        ( 'PALABCLAVE=Vacio' | 'TIPOA' | 'TIPOB' ) 
        'PALABCLAVE=Principal' block
\end{verbatim}

\begin{itemize}
    \item Detecta la definición \texttt{Func <tipo> Principal <block>}.
    \item Valida cada parte:
    \begin{itemize}
        \item \texttt{Func} al inicio,
        \item un tipo permitido,
        \item nombre \texttt{Principal}.
    \end{itemize}
    \item Genera un nodo AST \texttt{('main', tipo, block)} para uso 
      posterior.
\end{itemize}

\subsubsection*{Function Call}

\begin{verbatim}
func_declaration 
      ::= 'PALABCLAVE=Func' 
          ('PALABCLAVE=Vacio' | 'TIPOA' | 'TIPOB') 
          'ID' block
\end{verbatim}

\begin{itemize}
    \item Comprueba que empiece con \texttt{Func}.
    \item Verifica que el tipo sea válido.
    \item Construye y devuelve el nodo AST con el nombre y contenido del block.
\end{itemize}



\section{Referencias}
\renewcommand{\refname}{}

\begin{thebibliography}{9}

%---------------------------------------------------------------------------------
% Referencias, aunque creo que mejor deberíamos usar un .bib y llamarlas desde ahí, es más facil ---------------------------------------------------------
%---------------------------------------------------------------------------------

\bibitem{ref} \label{ref:lexPy1} J. R. Levine, T. Mason, and D. 
Brown, “Lex \& Yacc,” 2nd ed., O’Reilly \& Associates, 1992.

\bibitem{ref} \label{ref:lexPy2}  D. M. Beazley, “PLY (Python Lex‐Yacc)
Manual,” Version 3.11, 2023. [Online]. Available: https://www.dabeaz.com/ply/.

\bibitem{ref} \label{ref:rachas} J.~E.~Ortiz~Triviño, ``Lenguaje para 
  procesamiento de rachas,'' Documento interno, Universidad Nacional de 
    Colombia, enviado por correo electrónico, 6 de mayo de 2025.

\end{thebibliography}

\end{document}
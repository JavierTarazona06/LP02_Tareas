\documentclass{article}
\usepackage{graphicx}
\usepackage[style=ieee]{biblatex} % Establecer el estilo de las referencias como IEEE
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{titletoc}
\usepackage{adjustbox}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{array}
\usepackage{longtable}

\hypersetup{
    colorlinks=true,
    linkcolor=blue, % Color del texto del enlace
    urlcolor=blue % Color del enlace
}

\usepackage{longtable} % Agrega el paquete longtable

\definecolor{mygreen}{RGB}{0,128,0}

\usepackage{array} % Para personalizar la tabla
\usepackage{booktabs} % Para líneas horizontales de mejor calidad
\usepackage{graphicx} % Paquete para incluir imágenes
\usepackage{float}

% Definir márgenes
\usepackage[margin=1in]{geometry}

\renewcommand{\contentsname}{\textcolor{mygreen}{Tabla de Contenidos}}

\begin{document}

\begin{titlepage}
  \centering
  % Logo de la Universidad
  \includegraphics[width=0.48\textwidth]{logo_universidad.png}
  \par\vspace{2cm}

  % Nombre de la Universidad y detalles del curso
  {\Large \textbf{Universidad Nacional de Colombia} \par}
  \vspace{0.5cm}
  {\large Ingeniería de Sistemas y Computación \par}
  {\large 2025966 Lenguajes de Programación (02)\par}
  \vspace{3cm}

  % Detalles del laboratorio y actividad
  {\large \textbf{Tarea 14} \par}
  {\large Diseño del computador\par}
  \vspace{3cm}

  % Lista de integrantes
  {\large \textbf{Integrantes:} \par}
  \vspace{0.5cm}
  \begin{tabular}{ll}
    Javier Andrés Tarazona Jiménez & jtarazonaj@unal.edu.co \\
    Eder                           & -@unal.edu.co          \\
    Sebastián                      & -@unal.edu.co          \\
    David Felipe Marin Rosas       & dmarinro@unal.edu.co   \\
  \end{tabular}
  \par\vspace{3cm}

  % Fecha
  {\large Mayo 19 de 2025 \par}
\end{titlepage}

\tableofcontents % Inserta la tabla de contenidos

\newpage % Salto de página para separar la tabla de contenidos del contenido del documento

% Contenido del artículo----------------------------------------------------------

%---------------------------------------------------------------------------------
% Diseño del Computador ----------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Nombre Computador}

El computador presentado se denomina \textbf{ORISC-I}, una fusión entre las
palabras \textit{Oráculo} y \textbf{RISC}. El término \textit{Oráculo}, según
la literatura, hace referencia a un lugar sagrado donde se acudía en busca de
respuestas confiables. Esta metáfora representa nuestro objetivo: construir una
máquina eficiente, precisa y confiable, capaz de ejecutar operaciones con mayor
rapidez que un ser humano.

Por otro lado, \textbf{RISC} (Reduced Instruction Set Computer) alude a la
arquitectura utilizada, caracterizada por un conjunto reducido de instrucciones
simples pero suficientes, lo que permite optimizar la ejecución, facilitar la
implementación y favorecer el rendimiento general del sistema.

\section{Nombre de la empresa}

La empresa se denomina \textbf{UN Sparkle}, donde \textit{UN} hace referencia a
la Universidad Nacional de Colombia, institución a la que pertenecen los autores
de este proyecto, y \textit{Sparkle} significa “destello” en inglés. Este nombre
simboliza nuestra intención de proyectar nuestras ideas y desarrollos como
\textit{destellos de innovación}, capaces de generar un impacto positivo en
el ámbito académico y tecnológico.


\section{Diseño del computador}

El computador propuesto está basado en la arquitectura de Von Neumann.
En primer lugar, se cuentan con los buses que van a conectar con todos los componentes
que se presentan posteriormente.

\subsection{Buses}

El computador cuenta con tres buses principales que permiten la comunicación entre
la Unidad Central de Proceso (CPU), la Memoria Principal (RAM) y la Unidad de
Entrada/Salida. Estos buses son esenciales para implementar el
modelo de arquitectura Von Neumann, en el que todos los componentes
comparten un medio común de transmisión de información.

\subsubsection*{Bus de Datos}

Este bus se encarga de transportar las palabras de datos
(de 64 bits) entre los distintos módulos del sistema. Utilizado para:
\begin{itemize}
  \item Transferir instrucciones desde memoria hacia el registro de instrucciones (IR).
  \item Transferir datos entre registros, memoria, y dispositivos de E/S.
  \item Intercambiar operandos entre la CPU y la ALU.
\end{itemize}
El bus de datos es bidireccional, ya que tanto la CPU como la memoria y la E/S
pueden escribir o leer a través de él.

\subsubsection*{Bus de Control}

El bus de control transporta señales de sincronización y
comandos que determinan el tipo de operación a realizar en cada
ciclo del procesador. Estas señales incluyen:
\begin{itemize}
  \item Lectura de memoria
  \item Escritura de memoria
  \item Lectura/Escritura de E/S
  \item Activación de ALU
  \item Ciclo de instrucción (fetch, decode, execute)
\end{itemize}
El bus de control también incluye señales de interrupción, reset y
reloj, esenciales para el control del flujo de ejecución.

\subsubsection*{Bus de Direcciones}

Este bus se utiliza para especificar la ubicación de memoria o
dispositivo con el que se desea interactuar. En este computador, las
direcciones son de 24 bits, lo cual permite direccionar hasta
$2^{24} = 16,\!777,\!216$ posiciones (16 MiB) distintas.
Este bus es unidireccional, va desde la CPU hacia la memoria o
dispositivos de E/S, y es usado durante operaciones de lectura o
escritura para indicar la dirección objetivo.


\subsection{Unidad Central de Proceso (CPU)}

La CPU está compuesta por los dos módulos esenciales en un procesador clásico:

\begin{itemize}
  \item \textbf{Unidad Aritmético-Lógica (ALU):}
        \begin{itemize}
          \item Ejecuta operaciones matemáticas y lógicas.
          \item Contiene los \textbf{registros de propósito general}, además de los registros PC, SP, IR, ESTADO. Ver detalle del campo \texttt{ESTADO} más adelante.
        \end{itemize}
  \item \textbf{Unidad de Control (UC):}
        \begin{itemize}
          \item Incluye el \textbf{decodificador de instrucciones}, el \textbf{program counter (PC)} y el \textbf{registro de instrucciones (IR)}.
          \item Interpreta el \texttt{opcode} de cada palabra de instrucción y coordina el flujo de datos en el sistema.
        \end{itemize}
\end{itemize}

Ambas unidades están en \textbf{comunicación constante} para avanzar en la ejecución del programa, decodificando y ejecutando instrucciones de 64 bits mediante los buses conectados de datos, direcciones y control.

\subsubsection{Registros}

\begin{itemize}
  \item Codificados en 5 bits $\rightarrow$ \textbf{32 registros disponibles}.
  \item Se incluyen registros de propósito general (\texttt{R0} a \texttt{R31}), además de registros especiales:
        \begin{itemize}
          \item \textbf{\texttt{R0: PC}}: Program Counter: Apunta a la dirección de la próxima instrucción.
          \item \textbf{\texttt{R1: SP}}: Stack Pointer.
          \item \textbf{\texttt{R2: IR}}: Instruction Register: Almacena la instrucción actual que está siendo ejecutada.
          \item \textbf{\texttt{R3: ESTADO}}: Banderas que permiten obtener información sobre los resultados.
        \end{itemize}
\end{itemize}

\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|c|}
    \hline
    \textbf{Bit} & \textbf{Nombre} & \textbf{Significado}                                                \\
    \hline
    0            & \texttt{C}      & Resultado igual a cero (\texttt{== 0})                              \\
    1            & \texttt{P}      & Resultado estrictamente positivo (\texttt{> 0})                     \\
    2            & \texttt{N}      & Resultado estrictamente negativo (\texttt{< 0})                     \\
    3            & \texttt{D}      & \textbf{Desbordamiento (Overflow)}: el resultado no cabe en 64 bits \\
    4            & —               & \textbf{Reservado}                                                  \\
    5            & —               & \textbf{Reservado}                                                  \\
    6            & —               & \textbf{Reservado}                                                  \\
    7            & —               & \textbf{Reservado}                                                  \\
    \hline
  \end{tabular}
  \caption{Banderas del registro ESTADO}
\end{table}

\begin{itemize}
  \item \textbf{\texttt{R4} a \texttt{R31}}: Propósito general.
\end{itemize}

\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|}
    \hline
    \textbf{Registro}   & \textbf{Codificación} \\
    \hline
    \texttt{R0: PC}     & 00000                 \\
    \texttt{R1: SP}     & 00001                 \\
    \texttt{R2: IR}     & 00010                 \\
    \texttt{R3: ESTADO} & 00011                 \\
    \texttt{R4}         & 00100                 \\
    \vdots              & \vdots                \\
    \texttt{R31}        & 11111                 \\
    \hline
  \end{tabular}
  \caption{Tabla de registros}
\end{table}

\subsection{Memoria Principal (RAM)}

\begin{itemize}
  \item Se trata de una memoria direccionable de 24 bits, lo que permite un total de:
        \[
          2^{24} = 16,777,216 \, \text{posiciones} = 16 \, \text{MiB de memoria direccionable}
        \]
  \item Cada posición puede almacenar una palabra (8 Bytes).
  \item Está conectada a la Unidad de Servicio mediante los tres buses (datos, direcciones y control).
  \item Toda palabra de memoria contiene 64 bits, tanto para datos como para instrucciones. En caso de datos más pequeños (enteros de 32 bits o 8 bits), se usa alineamiento y enmascaramiento de bits.
  \item Es así que las direcciones de memoria van de:
        \[
          0x000000 \, \text{a} \, 0xFFFFFF
        \]
\end{itemize}

\subsubsection{Espacio reservado para pila}

El computador incluye un \textbf{modelo de pila} gestionado por el registro especial \texttt{SP} (Stack Pointer). La pila es una estructura \textbf{LIFO (Last In, First Out)} utilizada para almacenar temporalmente datos como:

\begin{itemize}
  \item Direcciones de retorno en llamadas a subrutinas (\texttt{CALL}, \texttt{RET})
  \item Registros temporales
  \item Variables locales
\end{itemize}

La pila \textbf{crece hacia direcciones de memoria menores}, es decir, cada operación \texttt{PUSH} decrementa el \texttt{SP}, y cada \texttt{POP} lo incrementa. Las instrucciones \texttt{PUSH Rn} y \texttt{POP Rn} permiten guardar o recuperar el contenido de un registro en la cima de la pila, respectivamente.

\begin{itemize}
  \item Las direcciones van de la 2.031.616 a la 16.777.215 (14.745.599 direcciones)
        \[
          0x1F0000 \, \text{a} \, 0xFFFFFF
        \]
\end{itemize}

\subsubsection{Espacio de datos}

\begin{itemize}
  \item Espacio para datos estáticos o globales.
  \item Es la parte media de la memoria.
  \item Las direcciones van de la 131.072 a la 2.031.615 (1.900.543 direcciones).
        \[
          0x020000 \, \text{a} \, 0x1EFFFF
        \]
\end{itemize}

\subsubsection{Espacio reservado para E/S}

\begin{itemize}
  \item Ver más detalles en la Unidad de Entrada y salida.
  \item Se ubica desde la dirección 65.536 hasta la 131.071 (65.536 direcciones).
        \[
          0x010000 \, \text{a} \, 0x01FFFF
        \]
\end{itemize}

\subsubsection{Espacio reservado para código}

\begin{itemize}
  \item En este espacio se van a guardar las instrucciones.
  \item Este espacio es la parte inferior de la memoria.
  \item Se ubica en la parte baja de la memoria, con direcciones de 0 a 65535 (65.536 direcciones):
        \[
          0x000000 \, \text{a} \, 0x00FFFF
        \]
\end{itemize}


\subsection{Unidad de Entrada y Salida (E/S)}

\begin{itemize}
  \item Administra la interacción con dispositivos periféricos.
  \item Opera tanto para entrada (recepción de datos) como para salida (envío de datos).
  \item Se comunica con la consola.
  \item El computador implementa \textbf{E/S mapeada en memoria (Memory-Mapped I/O)}, es decir, los dispositivos periféricos comparten el mismo espacio de direcciones que la memoria RAM.
  \item Se reserva un rango de direcciones para la comunicación con periféricos conectados a la Unidad de E/S. Esto permite acceder a los dispositivos usando instrucciones estándar, sin necesidad de instrucciones exclusivas de E/S.
\end{itemize}


\subsection{Instrucciones}

Las instrucciones del procesador están codificadas en palabras de 64 bits, siguiendo el formato:

\begin{table}[h!]
  \centering
  \begin{tabular}{|c|c|c|}
    \hline
    \textbf{Campo}                                     & \textbf{Bits} & \textbf{Descripción}                           \\
    \hline
    \texttt{Opcode}                                    & 6             & Código que determina la operación a ejecutar   \\
    \texttt{Registro destino}                          & 5             & Registro donde se almacenará el resultado      \\
    \texttt{Registro base}                             & 5             & Registro utilizado para direccionamiento base  \\
    \texttt{Memoria o Desplazamiento de registro base} & 24            & Offset o dirección absoluta en memoria         \\
    \texttt{Extra o valor Inmediato}                   & 24            & Reservado para ampliación o valores inmediatos \\
    \hline
  \end{tabular}
\end{table}

Este formato se \textbf{reutiliza} para los tres tipos de instrucciones:

\begin{itemize}
  \item \textbf{Tipo I (inmediato / memoria)}: todos los campos son relevantes.
  \item \textbf{Tipo R (entre registros)}: el campo \texttt{Memoria} puede representar un segundo registro o dejarse en cero.
  \item \textbf{Tipo J (salto)}: se usa el campo \texttt{Memoria} como dirección absoluta, y los demás campos se ignoran o se rellenan con ceros.
\end{itemize}

Esta salvedad aplica para todos los casos a no ser que se especifique lo contrario en una instrucción específica.

\subsubsection{Opcodes}

\begin{itemize}
  \item Codificados en 6 bits.
  \item Capacidad para definir \textbf{hasta 64 instrucciones distintas}.
  \item Instrucciones divididas en categorías: aritméticas, lógicas, control de flujo, memoria, E/S.
\end{itemize}


\subsection{Ciclos del Computador}

El ordenador va a pasar por los ciclos de \texttt{fetch-decode-execute}:

\subsubsection{Fetch}

\begin{itemize}
  \item La dirección de la siguiente instrucción se encuentra en el \textbf{PC (\texttt{R0})}.
  \item Se accede a la memoria, se lee la instrucción (64 bits) y se guarda en el \textbf{IR (\texttt{R2})}.
  \item El \texttt{PC} se incrementa en 1.
\end{itemize}

\subsubsection{Decode}

\begin{itemize}
  \item La Unidad de Control extrae el \texttt{opcode}, los registros y los operandos desde el \textbf{IR}.
  \item Determina el tipo de instrucción (I, R, J), identifica la instrucción y prepara el entorno.
\end{itemize}

\subsubsection{Execute}

\begin{itemize}
  \item Según el tipo de instrucción:
        \begin{itemize}
          \item \textbf{Tipo R}: la ALU ejecuta la operación entre registros.
          \item \textbf{Tipo I}: se accede a memoria usando direccionamiento con desplazamiento o directo.
          \item \textbf{Tipo J}: el \texttt{PC} se actualiza con la nueva dirección de salto.
        \end{itemize}
  \item Si aplica, se actualiza el registro \textbf{ESTADO (\texttt{R3})} con los indicadores del resultado.
\end{itemize}


\subsection{Detalles}

\subsubsection{Variables}

Las variables \textbf{globales} se almacenan en el segmento de
\textbf{datos estáticos}, ubicado entre las direcciones
\texttt{0x020000} y \texttt{0x1EFFFF}. Estas variables
existen durante toda la ejecución del programa.

Las variables \textbf{locales}, por el contrario, se
almacenan dinámicamente en la \textbf{pila}, gestionada por
el registro \texttt{SP}. Se reservan y liberan mediante
instrucciones que modifican el puntero de pila,
y solo existen mientras la subrutina
correspondiente está en ejecución.

\subsection{Microinstrucciones}

\begin{itemize}
  \item Cada una de 6 bits: Posibilidad de 64 instrucciones
  \item \textbf{R}: es para registros.
  \item \textbf{M}: es para dirección de memoria.
  \item \textbf{V}: es para valores inmediatos.
  \item Para diferenciar entre los contenidos de los registros y sus direcciones usamos la notación de punteros de C, donde \texttt{\&R} es la dirección del registro \texttt{R} y si R contiene una dirección, entonces .\texttt{*R} es el contenido de la dirección que contiene \texttt{R}.
\end{itemize}

\subsubsection{Tipo R: \textbf{entre registros}}

\begin{longtable}{|p{0.1\textwidth}|p{0.2\textwidth}|p{0.1\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}
  \hline
  \textbf{Número} & \textbf{Código Ensamblador} & \textbf{Código Máquina Binario} & \textbf{Instrucción}                                               & \textbf{Descripción}                       \\
  \hline
  1               & \texttt{SUMA R, R'}         & 000001                          & Suma dos registros R y R'                                          & $R \leftarrow  R + R'$                     \\
  \hline
  2               & \texttt{RESTA R, R'}        & 000010                          & Resta dos registros                                                & $R \leftarrow R - R'$                      \\
  \hline
  3               & \texttt{MULT R, R'}         & 000011                          & Multiplica dos registros                                           & $R \leftarrow R \times R'$                 \\
  \hline
  4               & \texttt{DIVI R, R'}         & 000100                          & Realiza la división entera entre dos registros                     & $\lfloor R \leftarrow R / R' \rfloor$      \\
  \hline
  5               & \texttt{AND R, R'}          & 000101                          & Conjunción bit a bit                                               & $R \leftarrow R \wedge R'$                 \\
  \hline
  6               & \texttt{OR R, R'}           & 000110                          & Disyunción bit a bit                                               & $R \leftarrow R \vee R'$                   \\
  \hline
  7               & \texttt{XOR R, R'}          & 000111                          & XOR bit a bit                                                      & $R \leftarrow R \oplus R'$                 \\
  \hline
  8               & \texttt{NOT R}              & 001000                          & Negación bit a bit                                                 & R ← $\sim$R (inversión de bits)            \\
  \hline
  9               & \texttt{COMP R, R'}         & 001001                          & Compara dos registros                                              & Actualiza el registro ESTADO (\texttt{R3}) \\
  \hline
  10              & \texttt{MUEV R, R'}         & 001010                          & Copia el valor de un registro a otro                               & R ← R'                                     \\
  \hline
  11              & \texttt{LIMP \&R}           & 001011                          & Limpia (pone en cero) un registro usando su dirección \texttt{\&R} & R ← 0                                      \\
  \hline
  12              & \texttt{INCRE R}            & 001100                          & Incrementa un registro en 1                                        & $R \leftarrow R + 1$                       \\
  \hline
\end{longtable}

\subsubsection{Tipo I: \textbf{inmediato / memoria}}

\begin{longtable}{|p{0.1\textwidth}|p{0.2\textwidth}|p{0.1\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}
  \hline
  \textbf{Número} & \textbf{Código}      & \textbf{Código Máquina Binario} & \textbf{Instrucción}                                                                                                                                                                          & \textbf{Descripción}                                                                                                \\
  \hline
  13              & \texttt{CARGA R, M}  & 001101                          & Carga desde el espacio de memoria M al registro R                                                                                                                                             & $R \leftarrow M$                                                                                                    \\
  \hline
  14              & \texttt{GUARD M, R}  & 001110                          & Guarda el contenido del registro R en el espacio de memoria M                                                                                                                                 & $M \leftarrow R$                                                                                                    \\
  \hline
  15              & \texttt{ICARGA R, V} & 001111                          & Carga un valor inmediato V a un registro R                                                                                                                                                    & $R \leftarrow V$                                                                                                    \\
  \hline
  16              & \texttt{ISUMA R, V}  & 010000                          & Suma inmediata de un valor V a un registro R                                                                                                                                                  & $R \leftarrow R + V$                                                                                                \\
  \hline
  17              & \texttt{IRESTA R, V} & 010001                          & Resta inmediata de un valor V a un registro R                                                                                                                                                 & $R \leftarrow R - V$                                                                                                \\
  \hline
  18              & \texttt{IMULT R, V}  & 010010                          & Multiplica un registro por un inmediato                                                                                                                                                       & $R \leftarrow R \times V$                                                                                           \\
  \hline
  19              & \texttt{IDIVI R, V}  & 010011                          & Realiza la división entera de un registro R entre un valor inmediato V                                                                                                                        & $R \Leftarrow \lfloor R / V \rfloor $                                                                               \\
  \hline
  20              & \texttt{IAND R, V}   & 010100                          & Conjunción AND entre un registro R y un valor inmediato V                                                                                                                                     & $ R \leftarrow R \wedge R'$                                                                                         \\
  \hline
  21              & \texttt{IOR R, V}    & 010101                          & Disyunción OR entre un registro R y un valor inmediato V                                                                                                                                      & $R \leftarrow R \vee R'$                                                                                            \\
  \hline
  22              & \texttt{IXOR R, V}   & 010110                          & XOR bit a bit entre un registro R y un valor inmediato V                                                                                                                                      & $R \leftarrow R \oplus R'$                                                                                          \\
  \hline
  23              & \texttt{ICOMP R, V}  & 010111                          & Compara un registro R con un valor inmediato V y guarda el resultado en R3 (Registro de estado)                                                                                               & Se realiza la resta $R - V$ y se indica si el resultado es positivo ($R > V$), negativo ($R < V$) o cero ($R = V$). \\
  \hline
  24              & \texttt{APILA R}     & 011000                          & Decrementa (la pila crece hacía abajo en la memoria) el registro SP (R1) y hace push del registro R en la pila (lo guarda)                                                                    & $R1 (SP) \leftarrow R1 - 1$ y guarda en la dirección que contiene SP a R:  $*SP \leftarrow R$                       \\
  \hline
  25              & \texttt{DESAPILA R}  & 011001                          & Guarda el contenido de la dirección que está en SP en el registro R, y luego incrementa SP (R1). (la pila crece hacía abajo, esto es un pop)                                                  & $R \leftarrow *SP(R1)$, luego incrementa SP: $R1(SP) \leftarrow  R1 + 1 $                                           \\
  \hline
  26              & \texttt{PROCRASTINA} & 011010                          & No hace nada (instrucción vacía), sirve para no hacer nada por un ciclo de reloj, se usa para temas de sincronización, o simplemente para que el PC se parezca un poco más a sus diseñadores. & Si quieres ver un anime en vez de hacer la tarea o irte a jugar r6 en vez de adelantar un trabajo.                  \\
  \hline
\end{longtable}

\subsubsection{Tipo J: \textbf{salto}}

\begin{longtable}{|p{0.1\textwidth}|p{0.2\textwidth}|p{0.1\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}
  \hline
  \textbf{Número}    & \textbf{Código}                                  & \textbf{Código Máquina Binario} & \textbf{Instrucción}                                                                                                                                                                                                          & \textbf{Descripción}                                                                                                   \\
  \hline
  27                 & \texttt{SALTA M}                                 & 011011                          & Salta incondicionalmente a la dirección M, es decir, guarda la dirección M en el R0 (PC) program counter para que en el siguiente ciclo continue desde ahí.                                                                   & $PC(R0) \leftarrow M$                                                                                                  \\
  \hline
  28                 & \texttt{LLAMA M}                                 & 011100                          & Llama a la subrutina en la dirección M, primero guarda el PC(R0) en la pila al hacer un APILA, luego pone en el PC (R0) el valor de M, donde empieza la subrutina.                                                            & APILA PC(R0) y luego: $PC \leftarrow M$                                                                                \\
  \hline
  29                 & \texttt{VUELVE}                                  & 011101                          & Vuelve desde la subrutina desde la que se encuentre, esto al hacer DESAPILA y guardar el resultado desapilado en el PC.                                                                                                       & DESAPILA R y luego: $PC \leftarrow R$                                                                                  \\
  \hline
  30                 & \texttt{SICERO M}                                & 011110                          & Salta si el resultado de la ultima comparación fue cero (C=1), al verificar el bit
  C del R3 (estado). & Verifica si C=1 y al confirmarlo hace un SALTA M                                                                                                                                                                                                                                                                                                                                                                                            \\
  \hline
  31                 & \texttt{SINCERO M}                               & 011111                          & Salta a M si el resultado de la última comparación no fue cero (C=0)                                                                                                                                                          & Verifica si C=0 en el R3 (estado) y al confirmarlo hace un SALTA M                                                     \\
  \hline
  32                 & \texttt{SIPOS M}                                 & 100000                          & Salta si el resultado de la última comparación fue positivo (P=1)                                                                                                                                                             & Verifica si P=1 y al confirmarlo hace un SALTA M                                                                       \\
  \hline
  33                 & \texttt{SINEG M}                                 & 100001                          & Salta si el resultado de la última comparación fue negativo (N=1)                                                                                                                                                             & Verifica si N=1 en el R3 (estado) y al confirmarlo hace un SALTA M                                                     \\
  \hline
  34                 & \texttt{SIOVERFL M}                              & 100010                          & Salta si el resultado de la última comparación u operación tuvo overflow (D=1)                                                                                                                                                & Verifica si (D=1) en R3 (estado) y al confirmarlo hace un SALTA M.                                                     \\
  \hline
  35                 & \texttt{SIREGCERO R M}                           & 100011                          & Salta a M si el registro R es igual a 0.                                                                                                                                                                                      & Verifica si R == 0 y al confirmarlo hace un SALTA M.                                                                   \\
  \hline
  36                 & \texttt{SIREGNCERO R M}                          & 100100                          & Salta a M si un registro R no es igual a cero.                                                                                                                                                                                & Verifica si R no es igual a cero y al confirmarlo, hace un SALTA M.                                                    \\
  \hline
  37                 & \texttt{SIMAYOR M}                               & 100101                          & Salta si el resultado de la ultima operación es de mayor que, es decir, al comparar, el resultado fue positivo y no fue igual a cero. $(P = 1 \land C = 0)$                                                                   & Verifica si los flags P y C cumplen las condiciones y al confirmarlo, hace un SALTA M.                                 \\
  \hline
  38                 & \texttt{SIMENOR}                                 & 100110                          & Salta si el resultado de la última operación es de menor que, es decir, al comparar, el resultado fue negativo.  (N=1)                                                                                                        & Verifica si el flag N en R3 (estado) está activado, al confirmarlo, hace un SALTA M.                                   \\
  \hline
  39                 & \texttt{PARA}                                    & 100111                          & Detiene la ejecución del programa                                                                                                                                                                                             & Se detiene el ciclo de instrucciones, ya sea deteniendo completamente la CPU o entrando en un estado de espera. (IDLE) \\
  \hline
  40                 & \texttt{INTERRUP M}                              & 101000                          & Dispara una interrupción por software, guardando el estado actual del program counter en la pila junto con los flags o registros relevantes, guarda el estado actual del sistema y luego salta a la rutina de interrupción M. & Primero se guardan los estados del sistema, como los registros especiales, se hace un APILA PC y se SALTA M.           \\
  \hline
\end{longtable}


%---------------------------------------------------------------------------------
% Enlazador Caragador  -----------------------------------------------------------
%---------------------------------------------------------------------------------


\section{Módulo Enlazador-Cargador}

%---------------------------------------------------------------------------------
% Algoritmos de Prueba -----------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Algoritmos de Prueba}

\subsection{Suma de N enteros consecutivos}

Un algoritmo de tipo iterativo que ....

\subsection{Conteo de ceros en un arreglo}

Un algoritmo de secuencial que....

\subsection{Factorial de un número}

Un algoritmo recursivo que ...

%---------------------------------------------------------------------------------
% Referencias -----------------------------------------------------------
%---------------------------------------------------------------------------------


\section{Referencias}
\renewcommand{\refname}{}

\begin{thebibliography}{9}

  \bibitem{ref} \label{ref:BPS} M. Bichler, S. Merting, and A. Uzunoglu,
  “Assigning Course Schedules: About Preference Elicitation, Fairness, and Truthfulness,”
  arXiv preprint arXiv:1812.02630, 2018. [En línea]. Disponible en:
  \url{https://arxiv.org/abs/1812.02630}


\end{thebibliography}

\end{document}
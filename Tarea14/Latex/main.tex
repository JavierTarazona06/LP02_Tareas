\documentclass{article}
\usepackage{graphicx}
\usepackage[style=ieee]{biblatex} % Establecer el estilo de las referencias como IEEE
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{titletoc}
\usepackage{adjustbox}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{array}
\usepackage{longtable}

\hypersetup{
    colorlinks=true,
    linkcolor=blue, % Color del texto del enlace
    urlcolor=blue % Color del enlace
}

\usepackage{longtable} % Agrega el paquete longtable

\definecolor{mygreen}{RGB}{0,128,0}

\usepackage{array} % Para personalizar la tabla
\usepackage{booktabs} % Para líneas horizontales de mejor calidad
\usepackage{graphicx} % Paquete para incluir imágenes
\usepackage{float}

% Definir márgenes
\usepackage[margin=1in]{geometry}

\renewcommand{\contentsname}{\textcolor{mygreen}{Tabla de Contenidos}}

\begin{document}

\begin{titlepage}
  \centering
  % Logo de la Universidad
  \includegraphics[width=0.48\textwidth]{logo_universidad.png}
  \par\vspace{2cm}

  % Nombre de la Universidad y detalles del curso
  {\Large \textbf{Universidad Nacional de Colombia} \par}
  \vspace{0.5cm}
  {\large Ingeniería de Sistemas y Computación \par}
  {\large 2025966 Lenguajes de Programación (02)\par}
  \vspace{3cm}

  % Detalles del laboratorio y actividad
  {\large \textbf{Tarea 14} \par}
  {\large Diseño del computador\par}
  \vspace{3cm}

  % Lista de integrantes
  {\large \textbf{Integrantes:} \par}
  \vspace{0.5cm}
  \begin{tabular}{ll}
    Javier Andrés Tarazona Jiménez & jtarazonaj@unal.edu.co \\
    Eder  José Hernández Buelvas   & ehernandezbu@unal.edu.co \\
    Juan Sebastián Muñoz Lemus     & jumunozle@unal.edu.co   \\
    David Felipe Marin Rosas       & dmarinro@unal.edu.co   \\
  \end{tabular}
  \par\vspace{3cm}

  % Fecha
  {\large Mayo 19 de 2025 \par}
\end{titlepage}

\tableofcontents % Inserta la tabla de contenidos

\newpage % Salto de página para separar la tabla de contenidos del contenido del documento

% Contenido del artículo----------------------------------------------------------

%---------------------------------------------------------------------------------
% Diseño del Computador ----------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Nombre Computador}

El computador presentado se denomina \textbf{ORISC-I}, una fusión entre las
palabras \textit{Oráculo} y \textbf{RISC}. El término \textit{Oráculo}, según
la literatura, hace referencia a un lugar sagrado donde se acudía en busca de
respuestas confiables. Esta metáfora representa nuestro objetivo: construir una
máquina eficiente, precisa y confiable, capaz de ejecutar operaciones con mayor
rapidez que un ser humano.

Por otro lado, \textbf{RISC} (Reduced Instruction Set Computer) alude a la
arquitectura utilizada, caracterizada por un conjunto reducido de instrucciones
simples pero suficientes, lo que permite optimizar la ejecución, facilitar la
implementación y favorecer el rendimiento general del sistema.

\section{Nombre de la empresa}

La empresa se denomina \textbf{UN Sparkle}, donde \textit{UN} hace referencia a
la Universidad Nacional de Colombia, institución a la que pertenecen los autores
de este proyecto, y \textit{Sparkle} significa “destello” en inglés. Este nombre
simboliza nuestra intención de proyectar nuestras ideas y desarrollos como
\textit{destellos de innovación}, capaces de generar un impacto positivo en
el ámbito académico y tecnológico.


\section{Diseño del computador}

El computador propuesto está basado en la arquitectura de Von Neumann.
En primer lugar, se cuentan con los buses que van a conectar con todos los componentes
que se presentan posteriormente.

\subsection{Buses}

El computador cuenta con tres buses principales que permiten la comunicación entre
la Unidad Central de Proceso (CPU), la Memoria Principal (RAM) y la Unidad de
Entrada/Salida. Estos buses son esenciales para implementar el
modelo de arquitectura Von Neumann, en el que todos los componentes
comparten un medio común de transmisión de información.

\subsubsection*{Bus de Datos}

Este bus se encarga de transportar las palabras de datos
(de 64 bits) entre los distintos módulos del sistema. Utilizado para:
\begin{itemize}
  \item Transferir instrucciones desde memoria hacia el registro de instrucciones (IR).
  \item Transferir datos entre registros, memoria, y dispositivos de E/S.
  \item Intercambiar operandos entre la CPU y la ALU.
\end{itemize}
El bus de datos es bidireccional, ya que tanto la CPU como la memoria y la E/S
pueden escribir o leer a través de él.

\subsubsection*{Bus de Control}

El bus de control transporta señales de sincronización y
comandos que determinan el tipo de operación a realizar en cada
ciclo del procesador. Estas señales incluyen:
\begin{itemize}
  \item Lectura de memoria
  \item Escritura de memoria
  \item Lectura/Escritura de E/S
  \item Activación de ALU
  \item Ciclo de instrucción (fetch, decode, execute)
\end{itemize}
El bus de control también incluye señales de interrupción, reset y
reloj, esenciales para el control del flujo de ejecución.

\subsubsection*{Bus de Direcciones}

Este bus se utiliza para especificar la ubicación de memoria o
dispositivo con el que se desea interactuar. En este computador, las
direcciones son de 24 bits, lo cual permite direccionar hasta
$2^{24} = 16,\!777,\!216$ posiciones (16 MiB) distintas.
Este bus es unidireccional, va desde la CPU hacia la memoria o
dispositivos de E/S, y es usado durante operaciones de lectura o
escritura para indicar la dirección objetivo.

\subsection{Memoria Principal (RAM)}

\begin{itemize}
  \item Se trata de una memoria direccionable de 24 bits, lo que permite un total de:
        \[
          2^{24} = 16,777,216 \, \text{posiciones} = 16 \, \text{MiB de memoria direccionable}
        \]
  \item Cada posición puede almacenar una palabra (8 Bytes).
  \item Está conectada a la Unidad de Servicio mediante los tres buses (datos, direcciones y control).
  \item Toda palabra de memoria contiene 64 bits, tanto para datos como para instrucciones. En caso de datos más pequeños (enteros de 32 bits o 8 bits), se usa alineamiento y enmascaramiento de bits.
  \item Es así que las direcciones de memoria van de:
        \[
          0x000000 \, \text{a} \, 0xFFFFFF
        \]
\end{itemize}

\subsubsection{Espacio reservado para pila}

El computador incluye un \textbf{modelo de pila} gestionado por el registro especial \texttt{SP} (Stack Pointer). La pila es una estructura \textbf{LIFO (Last In, First Out)} utilizada para almacenar temporalmente datos como:

\begin{itemize}
  \item Direcciones de retorno en llamadas a subrutinas (\texttt{CALL}, \texttt{RET})
  \item Registros temporales
  \item Variables locales
\end{itemize}

La pila \textbf{crece hacia direcciones de memoria menores}, es decir, cada operación \texttt{PUSH} decrementa el \texttt{SP}, y cada \texttt{POP} lo incrementa. Las instrucciones \texttt{PUSH Rn} y \texttt{POP Rn} permiten guardar o recuperar el contenido de un registro en la cima de la pila, respectivamente.

\begin{itemize}
  \item Las direcciones van de la 2.031.616 a la 16.777.215 (14.745.599 direcciones)
        \[
          0x1F0000 \, \text{a} \, 0xFFFFFF
        \]
\end{itemize}

\subsubsection{Espacio de datos}

\begin{itemize}
  \item Espacio para datos estáticos o globales.
  \item Es la parte media de la memoria.
  \item Las direcciones van de la 131.072 a la 2.031.615 (1.900.543 direcciones).
        \[
          0x020000 \, \text{a} \, 0x1EFFFF
        \]
\end{itemize}

\subsubsection{Espacio reservado para E/S}

\begin{itemize}
  \item Ver más detalles en la Unidad de Entrada y salida.
  \item Se ubica desde la dirección 65.536 hasta la 131.071 (65.536 direcciones).
        \[
          0x010000 \, \text{a} \, 0x01FFFF
        \]
\end{itemize}

\subsubsection{Espacio reservado para código}

\begin{itemize}
  \item En este espacio se van a guardar las instrucciones.
  \item Este espacio es la parte inferior de la memoria.
  \item Se ubica en la parte baja de la memoria, con direcciones de 0 a 65535 (65.536 direcciones):
        \[
          0x000000 \, \text{a} \, 0x00FFFF
        \]
\end{itemize}


\subsection{Unidad de Entrada y Salida (E/S)}

\begin{itemize}
  \item Administra la interacción con dispositivos periféricos.
  \item Opera tanto para entrada (recepción de datos) como para salida (envío de datos).
  \item Se comunica con la consola.
  \item El computador implementa \textbf{E/S mapeada en memoria (Memory-Mapped I/O)}, es decir, los dispositivos periféricos comparten el mismo espacio de direcciones que la memoria RAM.
  \item Se reserva un rango de direcciones para la comunicación con periféricos conectados a la Unidad de E/S. Esto permite acceder a los dispositivos usando instrucciones estándar, sin necesidad de instrucciones exclusivas de E/S.
\end{itemize}



\subsection{Unidad Central de Proceso (CPU)}

La CPU está compuesta por los dos módulos esenciales en un procesador clásico:

\begin{itemize}
  \item \textbf{Unidad Aritmético-Lógica (ALU):}
        \begin{itemize}
          \item Ejecuta operaciones matemáticas y lógicas.
          \item Contiene los \textbf{registros de propósito general}, además de los registros PC, SP, IR, ESTADO. Ver detalle del campo \texttt{ESTADO} más adelante.
        \end{itemize}
  \item \textbf{Unidad de Control (UC):}
        \begin{itemize}
          \item Incluye el \textbf{decodificador de instrucciones}, el \textbf{program counter (PC)} y el \textbf{registro de instrucciones (IR)}.
          \item Interpreta el \texttt{opcode} de cada palabra de instrucción y coordina el flujo de datos en el sistema.
        \end{itemize}
\end{itemize}

Ambas unidades están en \textbf{comunicación constante} para avanzar en la ejecución del programa, decodificando y ejecutando instrucciones de 64 bits mediante los buses conectados de datos, direcciones y control.

\subsubsection{Registros}

\begin{itemize}
  \item Codificados en 5 bits $\rightarrow$ \textbf{32 registros disponibles}.
  \item Se incluyen registros de propósito general (\texttt{R0} a \texttt{R31}), además de registros especiales:
        \begin{itemize}
          \item \textbf{\texttt{R0: PC}}: Program Counter: Apunta a la dirección de la próxima instrucción.
          \item \textbf{\texttt{R1: SP}}: Stack Pointer.
          \item \textbf{\texttt{R2: IR}}: Instruction Register: Almacena la instrucción actual que está siendo ejecutada.
          \item \textbf{\texttt{R3: ESTADO}}: Banderas que permiten obtener información sobre los resultados.
        \end{itemize}
\end{itemize}

\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|c|}
    \hline
    \textbf{Bit} & \textbf{Nombre} & \textbf{Significado}                                                \\
    \hline
    0            & \texttt{C}      & Resultado igual a cero (\texttt{== 0})                              \\
    1            & \texttt{P}      & Resultado estrictamente positivo (\texttt{> 0})                     \\
    2            & \texttt{N}      & Resultado estrictamente negativo (\texttt{< 0})                     \\
    3            & \texttt{D}      & \textbf{Desbordamiento (Overflow)}: el resultado no cabe en 64 bits \\
    4            & —               & \textbf{Reservado}                                                  \\
    5            & —               & \textbf{Reservado}                                                  \\
    6            & —               & \textbf{Reservado}                                                  \\
    7            & —               & \textbf{Reservado}                                                  \\
    \hline
  \end{tabular}
  \caption{Banderas del registro ESTADO}
\end{table}

\begin{itemize}
  \item \textbf{\texttt{R4} a \texttt{R31}}: Propósito general.
\end{itemize}

\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|}
    \hline
    \textbf{Registro}   & \textbf{Codificación} \\
    \hline
    \texttt{R0: PC}     & 00000                 \\
    \texttt{R1: SP}     & 00001                 \\
    \texttt{R2: IR}     & 00010                 \\
    \texttt{R3: ESTADO} & 00011                 \\
    \texttt{R4}         & 00100                 \\
    \vdots              & \vdots                \\
    \texttt{R31}        & 11111                 \\
    \hline
  \end{tabular}
  \caption{Tabla de registros}
\end{table}

\subsection{Ciclos del Computador}

El ordenador va a pasar por los ciclos de \texttt{fetch-decode-execute}:

\subsubsection{Fetch}

\begin{itemize}
  \item La dirección de la siguiente instrucción se encuentra en el \textbf{PC (\texttt{R0})}.
  \item Se accede a la memoria, se lee la instrucción (64 bits) y se guarda en el \textbf{IR (\texttt{R2})}.
  \item El \texttt{PC} se incrementa en 1.
\end{itemize}

\subsubsection{Decode}

\begin{itemize}
  \item La Unidad de Control extrae el \texttt{opcode}, los registros y los operandos desde el \textbf{IR}.
  \item Determina el tipo de instrucción (I, R, J), identifica la instrucción y prepara el entorno.
\end{itemize}

\subsubsection{Execute}

\begin{itemize}
  \item Según el tipo de instrucción:
        \begin{itemize}
          \item \textbf{Tipo R}: la ALU ejecuta la operación entre registros.
          \item \textbf{Tipo I}: se accede a memoria usando direccionamiento con desplazamiento o directo.
          \item \textbf{Tipo J}: el \texttt{PC} se actualiza con la nueva dirección de salto.
        \end{itemize}
  \item Si aplica, se actualiza el registro \textbf{ESTADO (\texttt{R3})} con los indicadores del resultado.
\end{itemize}



\subsection{Instrucciones}

Las instrucciones del procesador están codificadas 
en palabras de 64 bits.

Se aplcian las siguientes convenciones:
\begin{itemize}
  \item \textbf{R}: es para registros.
  \item \textbf{M}: es para dirección de memoria.
  \item \textbf{V}*: es para valores inmediatos. 
        Ocupa los 32 bits menos significativos de la instrucción. 
        A no ser
        de que se especifique lo contrario.
\end{itemize}

\subsubsection{Formatos de instrucción}

Dado que la longitud del opcode
es variable dependiendo de la instrucción,
Se han diseñado los siguientes tipos:\\

\textbf{De Código completo}

Instrucciones que realizan acciones de control

\begin{table}[H]
\centering
\begin{tabular}{|c|c|}
\hline
 & \textbf{Opcode} \\ \hline
\textbf{Bits} & 63 a 0 \\
\hline
\end{tabular}
\end{table}

\textbf{Intrucciones tipo R:}

Operaciones entre registros.

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
 & \textbf{Opcode} & \textbf{R}  \\ \hline
\textbf{Bits} &63 a 5 & 4 a 0 \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
 & \textbf{Opcode} & \textbf{R} & \textbf{R'} \\ \hline
\textbf{Bits} &63 a 10 & 9 a 5 & 4 a 0 \\
\hline
\end{tabular}
\end{table}


\textbf{Intrucciones tipo I:}

Operaciones con valores inmediatos o memoria.

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
 & \textbf{Opcode} & \textbf{R} & \textbf{M} \\ \hline
\textbf{Bits} &63 a 29 & 28 a 24 & 23 a 0 \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
 & \textbf{Opcode} & \textbf{R} & \textbf{V} \\ \hline
\textbf{Bits} &63 a 37 & 36 a 32 & 31 a 0 \\
\hline
\end{tabular}
\end{table}

\textbf{Intrucciones tipo J:}

Operaciones que saltan a una dirección de memoria o la manejan.

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
 & \textbf{Opcode} & \textbf{M} \\ \hline
\textbf{Bits} &63 a 24 & 23 a 0 \\
\hline
\end{tabular}
\end{table}

\subsubsection{Tablas de instrucciones}

\textbf{De Código completo}

\begin{longtable}{|p{0.2\textwidth}|p{0.25\textwidth}|p{0.25\textwidth}|p{0.3\textwidth}|}
  \hline
  \textbf{Código Ensamblador} & \textbf{Código Máquina Hexadecimal} & \textbf{Instrucción}                                               & \textbf{Descripción}                       \\
  \hline
  \texttt{PROCRASTINA}         &     & 
    No hace nada (instrucción vacía), sirve para no hacer nada por un ciclo de reloj, 
        se usa para temas de sincronización, o simplemente para que el PC se parezca un poco más 
        a sus diseñadores. & 
    Si quieres ver un anime en vez de hacer la tarea o irte a jugar r6 en vez de adelantar 
        un trabajo.\\
  \hline
  \texttt{VUELVE} &  & 
    Vuelve desde la subrutina desde la que se encuentre, esto al hacer DESAPILA y guardar 
        el resultado desapilado en el PC. & 
    DESAPILA R y luego: $PC \leftarrow R$                                                                                  \\
  \hline
  \texttt{PARA} &  & Detiene la ejecución del programa & 
    Se detiene el ciclo de instrucciones, ya sea deteniendo completamente la CPU o 
        entrando en un estado de espera (IDLE) \\
  \hline
\end{longtable}


\textbf{Intrucciones tipo R:}

\begin{longtable}{|p{0.2\textwidth}|p{0.25\textwidth}|p{0.25\textwidth}|p{0.3\textwidth}|}
  \hline
  \textbf{Código Ensamblador} & \textbf{Código Máquina Hexadecimal} & \textbf{Instrucción}                                               & \textbf{Descripción}                       \\
  \hline
  \texttt{SUMA R, R'}  &     & Suma dos registros R y R'                                          & $R \leftarrow  R + R'$                     \\
  \hline
  \texttt{RESTA R, R'} &     & Resta dos registros                                                & $R \leftarrow R - R'$                      \\
  \hline
  \texttt{MULT R, R'}  &     & Multiplica dos registros                                           & $R \leftarrow R \times R'$                 \\
  \hline
  \texttt{DIVI R, R'}  &     & Realiza la división entera entre dos registros                     & $\lfloor R \leftarrow R / R' \rfloor$      \\
  \hline
  \texttt{AND R, R'}   &     & Conjunción bit a bit                                               & $R \leftarrow R \wedge R'$                 \\
  \hline
  \texttt{OR R, R'}    &     & Disyunción bit a bit                                               & $R \leftarrow R \vee R'$                   \\
  \hline
  \texttt{XOR R, R'}   &     & XOR bit a bit                                                      & $R \leftarrow R \oplus R'$                 \\
  \hline
  \texttt{COMP R, R'}  &     & Compara dos registros                                              & Actualiza el registro ESTADO \\
  \hline
  \texttt{COPIA R, R'} &     & Copia el valor de un registro a otro                               & R ← R'                                     \\
  \hline
  \texttt{NOT R}       &     & Negación bit a bit                                                 & R ← $\sim$R (inversión de bits)            \\
  \hline
  \texttt{LIMP R}    &     & Limpia (pone en cero) el contenido de un registro & R ← 0                                      \\
  \hline
  \texttt{INCRE R}     &     & Incrementa un registro en 1                                        & $R \leftarrow R + 1$                       \\
  \hline
  \texttt{DECRE R}     &     & Decrementa un registro en 1                                        & $R \leftarrow R - 1$                       \\
  \hline
  \texttt{APILA R}     &     & Decrementa (la pila crece hacia abajo en la memoria) el registro SP (R1) y hace push del registro R en la pila (lo guarda)                                                                    & $R1 (SP) \leftarrow R1 - 1$ y guarda en la dirección que contiene SP a R:  $*SP \leftarrow R$                       \\
  \hline
  \texttt{DESAPILA R}  &     & Guarda el contenido de la dirección que está en SP en el registro R, y luego incrementa SP (R1). (la pila crece hacia abajo, esto es un pop)                                                  & $R \leftarrow *SP(R1)$, luego incrementa SP: $R1(SP) \leftarrow  R1 + 1 $                                           \\
  \hline
\end{longtable}

\textbf{Intrucciones tipo I:}

\begin{longtable}{|p{0.2\textwidth}|p{0.25\textwidth}|p{0.25\textwidth}|p{0.3\textwidth}|}
  \hline
  \textbf{Código Ensamblador} & \textbf{Código Máquina Hexadecimal} & \textbf{Instrucción}                                               & \textbf{Descripción}                       \\
  \hline
  \texttt{CARGA R, M}  &  & Carga desde el espacio de memoria M al registro R                                                                                                                                             & $R \leftarrow M$                                                                                                    \\
  \hline
  \texttt{GUARD R, M}  &  & Guarda el contenido del registro R en el espacio de memoria M                                                                                                                                 & $M \leftarrow R$                                                                                                    \\
  \hline
  \texttt{SIREGCERO R M}   &  & Salta a M si el registro R es igual a 0.                                                                                                                                                    & Verifica si R == 0 y al confirmarlo hace un SALTA M.                                                                   \\
  \hline
  \texttt{SIREGNCERO R M}  &  & Salta a M si un registro R no es igual a cero.                                                                                                                                              & Verifica si R $\neq$ 0 y al confirmarlo hace un SALTA M.                                                                    \\
  \hline
  \texttt{ICARGA R, V} &  & Carga un valor inmediato V a un registro R. V se guarda en los 32 bits menos significativos del registro.                                                                                     & $R \leftarrow V$                                                                                                    \\
  \hline
  \texttt{ISCARGA R, V}&  & Carga un valor inmediato V a un registro R.  V se guarda en los 32 bits más significativos del registro.                                                                                      & $R \leftarrow V$                                                                                                    \\
  \hline
  \texttt{ISUMA R, V}  &  & Suma inmediata de un valor V a un registro R                                                                                                                                                  & $R \leftarrow R + V$                                                                                                \\
  \hline
  \texttt{IRESTA R, V} &  & Resta inmediata de un valor V a un registro R                                                                                                                                                 & $R \leftarrow R - V$                                                                                                \\
  \hline
  \texttt{IMULT R, V}  &  & Multiplica un registro por un inmediato                                                                                                                                                       & $R \leftarrow R \times V$                                                                                           \\
  \hline
  \texttt{IDIVI R, V}  &  & Realiza la división entera de un registro R entre un valor inmediato V                                                                                                                        & $R \Leftarrow \lfloor R / V \rfloor $                                                                               \\
  \hline
  \texttt{IAND R, V}   &  & Conjunción AND entre un registro R y un valor inmediato V                                                                                                                                     & $ R \leftarrow R \wedge R'$                                                                                         \\
  \hline
  \texttt{IOR R, V}    &  & Disyunción OR entre un registro R y un valor inmediato V                                                                                                                                      & $R \leftarrow R \vee R'$                                                                                            \\
  \hline
  \texttt{IXOR R, V}   &  & XOR bit a bit entre un registro R y un valor inmediato V                                                                                                                                      & $R \leftarrow R \oplus R'$                                                                                          \\
  \hline
  \texttt{ICOMP R, V}  &  & Compara un registro R con un valor inmediato V y guarda el resultado en R3 (Registro de estado)                                                                                               & Se realiza la resta $R - V$ y se indica si el resultado es positivo ($R > V$), negativo ($R < V$) o cero ($R = V$). \\
  \hline
\end{longtable}

\textbf{Intrucciones tipo J:}

\begin{longtable}{|p{0.2\textwidth}|p{0.25\textwidth}|p{0.25\textwidth}|p{0.3\textwidth}|}
  \hline
  \textbf{Código Ensamblador} & \textbf{Código Máquina Hexadecimal} & \textbf{Instrucción}                                               & \textbf{Descripción}                       \\
  \hline
  \texttt{SALTA M}     &  & Salta incondicionalmente a la dirección M, es decir, guarda la dirección M en el R0 (PC) program counter para que en el siguiente ciclo continúe desde ahí.                              & $PC(R0) \leftarrow M$                                                                                                  \\
  \hline
  \texttt{LLAMA M}     &  & Llama a la subrutina en la dirección M, primero guarda el PC(R0) en la pila al hacer un APILA, luego pone en el PC (R0) el valor de M, donde empieza la subrutina.                        & APILA PC(R0) y luego: $PC \leftarrow M$                                                                                \\
  \hline
  \texttt{SICERO M}    &  & Salta si el resultado de la última comparación fue cero (C=1), al verificar el bit C del R3 (estado).                                                                                    & Verifica si C=1 y al confirmarlo hace un SALTA M                                                                       \\
  \hline
  \texttt{SINCERO M}   &  & Salta a M si el resultado de la última comparación no fue cero (C=0)                                                                                                                       & Verifica si C=0 en el R3 (estado) y al confirmarlo hace un SALTA M                                                     \\
  \hline
  \texttt{SIPOS M}     &  & Salta si el resultado de la última comparación fue positivo (P=1)                                                                                                                          & Verifica si P=1 y al confirmarlo hace un SALTA M                                                                       \\
  \hline
  \texttt{SINEG M}     &  & Salta si el resultado de la última comparación fue negativo (N=1)                                                                                                                          & Verifica si N=1 en el R3 (estado) y al confirmarlo hace un SALTA M                                                     \\
  \hline
  \texttt{SIOVERFL M}  &  & Salta si el resultado de la última comparación u operación tuvo overflow (D=1)                                                                                                            & Verifica si D=1 en R3 (estado) y al confirmarlo hace un SALTA M.                                                       \\
  \hline
  \texttt{SIMAYOR M}   &  & Salta si el resultado de la última operación es de mayor que, es decir, al comparar, el resultado fue positivo y no fue igual a cero. $(P = 1 \land C = 0)$                              & Verifica si los flags P y C cumplen las condiciones y al confirmarlo hace un SALTA M.                                 \\
  \hline
  \texttt{SIMENOR M}   &  & Salta si el resultado de la última operación es de menor que, es decir, al comparar, el resultado fue negativo. (N=1)                                                                    & Verifica si el flag N en R3 (estado) está activado, al confirmarlo hace un SALTA M.                                   \\
  \hline
  \texttt{INTERRUP M}  &  & Dispara una interrupción por software, guardando el estado actual del program counter en la pila junto con los flags o registros relevantes, luego salta a la rutina de interrupción M.  & Se guardan los estados del sistema, se hace un APILA PC y se SALTA M.                                                  \\
  \hline
\end{longtable}


%---------------------------------------------------------------------------------
% Detalles  -----------------------------------------------------------
%---------------------------------------------------------------------------------

\subsection{Detalles}

\subsubsection{Variables}

Las variables \textbf{globales} se almacenan en el segmento de
\textbf{datos estáticos}, ubicado entre las direcciones
\texttt{0x020000} y \texttt{0x1EFFFF}. Estas variables
existen durante toda la ejecución del programa.

Las variables \textbf{locales}, por el contrario, se
almacenan dinámicamente en la \textbf{pila}, gestionada por
el registro \texttt{SP}. Se reservan y liberan mediante
instrucciones que modifican el puntero de pila,
y solo existen mientras la subrutina
correspondiente está en ejecución.

\subsubsection{Tipos de datos}

\textbf{Representación de enteros}

En el computador \textbf{ORISC-I}, los números enteros se representan en formato de \textit{complemento a dos} sobre \textbf{64 bits}. 

Esto permite representar eficientemente tanto enteros positivos como negativos, sin necesidad de un bit de signo separado ni lógica adicional para la ALU.

El \textit{bit más significativo} (MSB, por sus siglas en inglés) indica el signo del número:

\begin{itemize}
    \item Si el MSB es \textbf{0}, el número es \textbf{positivo}.
    \item Si el MSB es \textbf{1}, el número es \textbf{negativo} (en complemento a dos).
\end{itemize}

\textbf{Representación de números en punto flotante}

Para representar números en punto flotante, el computador \textbf{ORISC-I} adopta el estándar \textbf{IEEE 754 de doble precisión} (\textit{64 bits}).

Cada palabra puede codificar un número real con la siguiente estructura:

\begin{itemize}
    \item \textbf{1 bit} de signo.
    \item \textbf{11 bits} para el exponente, con un \textit{sesgo de 1023}.
    \item \textbf{52 bits} para la mantisa (fracción).
\end{itemize}

En versiones futuras, se planea implementar instrucciones especializadas para operaciones aritméticas en coma flotante, tales como:

\texttt{FADD}, \texttt{FSUB}, \texttt{FMUL}, \texttt{FDIV}.

\textbf{Manejar valores inmediatos grandes}

Las instrucciones de tipo \textbf{I} permiten cargar \textit{inmediatos} de hasta \textbf{24 bits}.  
Para valores negativos, se realiza automáticamente una \textit{extensión de signo} 
a 64 bits utilizando el formato de \textit{complemento a dos}.

Si se desea cargar valores inmediatos mayores a 24 bits, se propone una 
estrategia extendida basada en dos instrucciones secuenciales:

\begin{itemize}
    \item Una instrucción tipo \texttt{LUI} (\textit{Load Upper Immediate}) carga los bits superiores.
    \item Una instrucción tipo \texttt{ORI} (\textit{OR Immediate}) combina los bits inferiores.
\end{itemize}

Pero en un diseño posterior o si se requiere para extender funcionalidades.


%---------------------------------------------------------------------------------
% Enlazador Caragador  -----------------------------------------------------------
%---------------------------------------------------------------------------------


\section{Módulo Enlazador–Cargador}

El Módulo Enlazador–Cargador se encarga de preparar y montar en la memoria RAM un programa en código máquina generado por el ensamblador. A continuación se detallan las responsabilidades específicas de cada parte:
\subsection{Enlazador}

El módulo Enlazador se encarga de combinar varios módulos objeto y bibliotecas para generar un único programa ejecutable. Sus tareas principales incluyen:

\begin{enumerate}
\item \textbf{Análisis de dependencias:}\\
Examina las referencias a símbolos externos en cada módulo objeto y determina la secuencia de enlace adecuada.

\item \textbf{Construcción de la tabla de símbolos global:}\\
Fusiona las tablas de símbolos de todos los módulos, asignando direcciones provisionales a los símbolos definidos y marcando los externos no resueltos.

\item \textbf{Resolución de referencias cruzadas:}\\
Para cada símbolo externo referenciado, busca su definición en la tabla global y actualiza las referencias en el código objeto con direcciones relativas o absolutas según convenga.

\item \textbf{Gestión de bibliotecas:}\\
Incluye en el ejecutable sólo los módulos necesarios de las bibliotecas estáticas, minimizando el tamaño final.

\item \textbf{Generación del fichero ejecutable:}\\
Ensambla los segmentos relocados en un único fichero de salida con formato ejecutable, incluyendo una cabecera que especifica:
\begin{itemize}
\item Dirección de carga predeterminada.
\item Punto de entrada (símbolo \texttt{main}).
\item Tamaños y ubicaciones de segmentos de código, datos y pila.
\end{itemize}

\item \textbf{Producción de información de depuración (opcional):}\\
Incorpora en el ejecutable tablas de símbolos y mapas de segmentos para facilitar el debugging y análisis de rendimiento.
\end{enumerate}

\subsection{Cargador}

\begin{enumerate}
\item \textbf{Lectura de cabecera del programa:}\\
El cargador extrae del fichero de objeto la tabla de segmentos (código, datos, pila) y la tabla de símbolos relocables, incluyendo:
\begin{itemize}
\item Dirección de carga propuesta por el usuario.
\item Tamaños de cada segmento.
\item Entradas relocables (instrucciones o datos con direcciones relativas).
\end{itemize}

\item \textbf{Relocalización de direcciones:}\\
Para cada entrada relocable, modifica el campo de dirección sumándole la \emph{dirección de carga base}:
$       \text{dirección\_absoluta} = \text{dirección\_relativa} + \text{base\_carga}
    $
De esta forma convierte todas las referencias relativas a direcciones absolutas en el espacio de memoria.

\item \textbf{Resolución de símbolos externos:}\\
Si el programa referenció símbolos definidos en otros módulos, busca en la tabla de símbolos del enlazador las direcciones finales y parchea las instrucciones correspondientes con sus direcciones absolutas.

\item \textbf{Escritura en memoria RAM:}\\
\begin{itemize}
\item Copia el segmento de código (instrucciones de 64 bits) en las celdas de memoria a partir de la dirección de carga base.
\item Copia el segmento de datos inicializados en las celdas posteriores.
\item Ajusta el puntero de pila (\texttt{SP}) al espacio reservado para la pila, calculado en función de la dirección de carga.
\end{itemize}

\item \textbf{Inicialización de registros de control:}\\
\begin{itemize}
\item Carga el registro \texttt{PC} (contador de programa) con la dirección de entrada especificada en la cabecera.
\item Borra o inicializa el registro \texttt{ESTADO} (banderas) a cero.
\end{itemize}

\item \textbf{Verificación y chequeo de errores:}\\
Comprueba que ninguna dirección de carga exceda los límites de la memoria disponible y que no haya solapamiento entre segmentos. En caso de error, devuelve un código de fallo.

\item \textbf{Transferencia de control:}\\
Una vez completada la carga, transfiere el control de la ejecución al \texttt{PC}, iniciando el ciclo de fetch–decode–execute de la CPU.
\end{enumerate}


\section{Algoritmos de Prueba}

\subsection{Suma de N enteros consecutivos}

Un algoritmo de tipo iterativo que suma los primeros N enteros
consecutivos usando un ciclo \texttt{for} y una variable acumuladora:

\begin{verbatim}
  int suma(int n) {
    int i, suma = 0;
    for (i = 1; i <= n; i++) {
      suma += i;
    }
    return suma;
  }
\end{verbatim}

Ahora, lo escribiremos en terminos del lenguaje ensamblador para nuestro computador ORISC-I:

\begin{verbatim}
  // Suma de N enteros consecutivos
  // ORISC-I
  // Entradas: R4 = N >= 1
  // Salidas: R5 = Suma
  // Variables: R6 = i, R5 = Suma

  // Inicializar variables en 0
  LIMP R5
  LIMP R6
  ICARGA R6, 0
  COPIA R5, R6
  // Inicio del loop
  LOOP_START:
    COMP R4, R6
    SICERO LOOP_END
    // Incrementar i
    INCRE R6
    // Sumar i al resultado (suma)
    SUMA R5, R6
    // Volver al inicio del loop
    SALTA LOOP_START
  LOOP_END:
  // Fin del loop
  // El resultado está en R5
\end{verbatim}

\subsection{Conteo de ceros en un arreglo}

Un algoritmo iterativo que recorre un arreglo y cuenta cuántas celdas contienen el valor cero:

\begin{verbatim}
// Conteo de ceros en un arreglo
// ORISC-I
// Entradas: R3 = dirección base del arreglo; R4 = longitud N >= 1
// Salidas: R5 = Cantidad de ceros
// Variables: R6 = índice i, R7 = valor actual, R8 = registro auxiliar, R9 = cero

// Inicializar contadores y registros
LIMP R5          // R5 = 0 (contador de ceros)
LIMP R6          // R6 = 0 (índice)
ICARGA R6, 0     // Asegura R6 = 0
COPIA R5, R6     // R5 = 0
LIMP R9          // R9 = 0 (valor cero para comparación)

// Inicio del loop
LOOP_START:
  COMP R6, R4
  SICERO LOOP_END      // Si i == N, terminar
  // Calcular dirección del elemento: R8 = R3 + R6
  COPIA R8, R3
  SUMA R8, R6
  // Cargar elemento en R7
  CARGA R7, R8
  // Comparar elemento con 0
  COMP R7, R9
  SICERO INCREMENT_COUNT
  SALTA CHECK_END
  INCREMENT_COUNT:
    INCRE R5            // count++
  CHECK_END:
    INCRE R6            // i++
    SALTA LOOP_START
LOOP_END:
// Resultado: R5 contiene el número de ceros
\end{verbatim}


\subsection{Factorial de un número}


\begin{verbatim}

int factorial(int n) {
    if (n == 0)
        return 1;
    else
        return n * factorial(n - 1);
}
\end{verbatim}
Ahora, lo escribiremos en terminos del lenguaje ensamblador para nuestro computador ORISC-I:

\begin{verbatim}

; factorial(n) en ensamblador
; Entrada: R4 = n
; Salida:  R5 = factorial(n)

; factorial(n) en ensamblador
; Entrada: R4 = n
; Salida:  R5 = factorial(n)

; factorial(n)
; Entrada: R4 = n
; Salida: R5 = factorial(n)

FACTORIAL:
    APILAR R4              ; Guardar n en la pila
    ICARGA R6, #0         ; Cargar 0 en R6
    COMP   R4, R6         ; Comparar n con 0 (actualiza R3)
    SICERO   BASE_CASE      ; Si n == 0, ir a caso base
    ICARGA R7, #1         ; Cargar 1 en R7
    RESTA   R4, R7         ; R4 = R4 - 1
    LLAMA  FACTORIAL      ; Llamar recursivamente factorial(n-1)
    DESAPILAR   R6             ; Recuperar n original en R6
    COPIA   R7, R5         ; Guardar factorial(n-1) en R7
    COPIA   R5, R6         ; Poner n en R5
    MULT   R5, R7         ; R5 = n * factorial(n-1)
    VUELVE                ; Retornar con resultado en R5
BASE_CASE:
    ICARGA R5, #1         ; factorial(0) = 1
    DESAPILAR   R4             ; Restaurar n antes de retornar
    VUELVE

\end{verbatim}

%---------------------------------------------------------------------------------
% Referencias -----------------------------------------------------------
%---------------------------------------------------------------------------------


\section{Referencias}
\renewcommand{\refname}{}

\begin{thebibliography}{9}

  \bibitem{ref} \label{ref:BPS} M. Bichler, S. Merting, and A. Uzunoglu,
  “Assigning Course Schedules: About Preference Elicitation, Fairness, and Truthfulness,”
  arXiv preprint arXiv:1812.02630, 2018. [En línea]. Disponible en:
  \url{https://arxiv.org/abs/1812.02630}


\end{thebibliography}

\end{document}


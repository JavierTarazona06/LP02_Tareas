\documentclass{article}
\usepackage{graphicx}
\usepackage[style=ieee]{biblatex} % Establecer el estilo de las referencias como IEEE
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{titletoc}
\usepackage{adjustbox}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{array}

\hypersetup{
    colorlinks=true,
    linkcolor=blue, % Color del texto del enlace
    urlcolor=blue % Color del enlace
}

\usepackage{longtable} % Agrega el paquete longtable

\definecolor{mygreen}{RGB}{0,128,0}

\usepackage{array} % Para personalizar la tabla
\usepackage{booktabs} % Para líneas horizontales de mejor calidad
\usepackage{graphicx} % Paquete para incluir imágenes
\usepackage{float}

% Definir márgenes
\usepackage[margin=1in]{geometry}

\renewcommand{\contentsname}{\textcolor{mygreen}{Tabla de Contenidos}}

\begin{document}

\begin{titlepage}
    \centering
    % Logo de la Universidad
    \includegraphics[width=0.48\textwidth]{logo_universidad.png}
    \par\vspace{2cm}

    % Nombre de la Universidad y detalles del curso
    {\Large \textbf{Universidad Nacional de Colombia} \par}
    \vspace{0.5cm}
    {\large Ingeniería de Sistemas y Computación \par}
    {\large 2025966 Lenguajes de Programación (02)\par}
    \vspace{3cm}

    % Detalles del laboratorio y actividad
    {\large \textbf{Tarea 14} \par}
    {\large Diseño del computador\par}
    \vspace{3cm}

    % Lista de integrantes
    {\large \textbf{Integrantes:} \par}
    \vspace{0.5cm}
    \begin{tabular}{ll}
    Javier Andrés Tarazona Jiménez & jtarazonaj@unal.edu.co \\
    Eder & -@unal.edu.co \\
    Sebastián & -@unal.edu.co \\
    \end{tabular}
    \par\vspace{3cm}

    % Fecha
    {\large Mayo 19 de 2025 \par}
\end{titlepage}

\tableofcontents % Inserta la tabla de contenidos

\newpage % Salto de página para separar la tabla de contenidos del contenido del documento

% Contenido del artículo----------------------------------------------------------

%---------------------------------------------------------------------------------
% Diseño del Computador ----------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Nombre Computador}

El computador presentado se denomina \textbf{ORISC-I}, una fusión entre las 
palabras \textit{Oráculo} y \textbf{RISC}. El término \textit{Oráculo}, según 
la literatura, hace referencia a un lugar sagrado donde se acudía en busca de 
respuestas confiables. Esta metáfora representa nuestro objetivo: construir una 
máquina eficiente, precisa y confiable, capaz de ejecutar operaciones con mayor 
rapidez que un ser humano.

Por otro lado, \textbf{RISC} (Reduced Instruction Set Computer) alude a la 
arquitectura utilizada, caracterizada por un conjunto reducido de instrucciones 
simples pero suficientes, lo que permite optimizar la ejecución, facilitar la 
implementación y favorecer el rendimiento general del sistema.

\section{Nombre de la empresa}

La empresa se denomina \textbf{UN Sparkle}, donde \textit{UN} hace referencia a 
la Universidad Nacional de Colombia, institución a la que pertenecen los autores 
de este proyecto, y \textit{Sparkle} significa “destello” en inglés. Este nombre 
simboliza nuestra intención de proyectar nuestras ideas y desarrollos como 
\textit{destellos de innovación}, capaces de generar un impacto positivo en 
el ámbito académico y tecnológico.


\section{Diseño del computador}

El computador propuesto está basado en la arquitectura de Von Neumann.
En primer lugar, se cuentan con los buses que van a conectar con todos los componentes 
que se presentan posteriormente.

\subsection{Buses}

El computador cuenta con tres buses principales que permiten la comunicación entre 
la Unidad Central de Proceso (CPU), la Memoria Principal (RAM) y la Unidad de 
Entrada/Salida. Estos buses son esenciales para implementar el 
modelo de arquitectura Von Neumann, en el que todos los componentes 
comparten un medio común de transmisión de información.

\subsubsection*{Bus de Datos}

Este bus se encarga de transportar las palabras de datos 
(de 64 bits) entre los distintos módulos del sistema. Utilizado para:
\begin{itemize}
  \item Transferir instrucciones desde memoria hacia el registro de instrucciones (IR).
  \item Transferir datos entre registros, memoria, y dispositivos de E/S.
  \item Intercambiar operandos entre la CPU y la ALU.
\end{itemize}
El bus de datos es bidireccional, ya que tanto la CPU como la memoria y la E/S 
pueden escribir o leer a través de él.

\subsubsection*{Bus de Control}

El bus de control transporta señales de sincronización y 
comandos que determinan el tipo de operación a realizar en cada 
ciclo del procesador. Estas señales incluyen:
\begin{itemize}
  \item Lectura de memoria
  \item Escritura de memoria
  \item Lectura/Escritura de E/S
  \item Activación de ALU
  \item Ciclo de instrucción (fetch, decode, execute)
\end{itemize}
El bus de control también incluye señales de interrupción, reset y 
reloj, esenciales para el control del flujo de ejecución.

\subsubsection*{Bus de Direcciones}

Este bus se utiliza para especificar la ubicación de memoria o 
dispositivo con el que se desea interactuar. En este computador, las 
direcciones son de 24 bits, lo cual permite direccionar hasta 
$2^{24} = 16,\!777,\!216$ posiciones (16 MiB) distintas. 
Este bus es unidireccional, va desde la CPU hacia la memoria o 
dispositivos de E/S, y es usado durante operaciones de lectura o 
escritura para indicar la dirección objetivo.


\subsection{Unidad Central de Proceso (CPU)}

La CPU está compuesta por los dos módulos esenciales en un procesador clásico:

\begin{itemize}
    \item \textbf{Unidad Aritmético-Lógica (ALU):}
    \begin{itemize}
        \item Ejecuta operaciones matemáticas y lógicas.
        \item Contiene los \textbf{registros de propósito general}, además de los registros PC, SP, IR, ESTADO. Ver detalle del campo \texttt{ESTADO} más adelante.
    \end{itemize}
    \item \textbf{Unidad de Control (UC):}
    \begin{itemize}
        \item Incluye el \textbf{decodificador de instrucciones}, el \textbf{program counter (PC)} y el \textbf{registro de instrucciones (IR)}.
        \item Interpreta el \texttt{opcode} de cada palabra de instrucción y coordina el flujo de datos en el sistema.
    \end{itemize}
\end{itemize}

Ambas unidades están en \textbf{comunicación constante} para avanzar en la ejecución del programa, decodificando y ejecutando instrucciones de 64 bits mediante los buses conectados de datos, direcciones y control.

\subsubsection{Registros}

\begin{itemize}
    \item Codificados en 5 bits $\rightarrow$ \textbf{32 registros disponibles}.
    \item Se incluyen registros de propósito general (\texttt{R0} a \texttt{R31}), además de registros especiales:
    \begin{itemize}
        \item \textbf{\texttt{R0: PC}}: Program Counter: Apunta a la dirección de la próxima instrucción.
        \item \textbf{\texttt{R1: SP}}: Stack Pointer.
        \item \textbf{\texttt{R2: IR}}: Instruction Register: Almacena la instrucción actual que está siendo ejecutada.
        \item \textbf{\texttt{R3: ESTADO}}: Banderas que permiten obtener información sobre los resultados al realizar una instrucción.
    \end{itemize}
\end{itemize}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
    \hline
    \textbf{Bit} & \textbf{Nombre} & \textbf{Significado} \\
    \hline
    0 & \texttt{C} & Resultado igual a cero (\texttt{== 0}) \\
    1 & \texttt{P} & Resultado estrictamente positivo (\texttt{> 0}) \\
    2 & \texttt{N} & Resultado estrictamente negativo (\texttt{< 0}) \\
    3 & \texttt{D} & \textbf{Desbordamiento (Overflow)}: el resultado no cabe en 64 bits \\
    4 & — & \textbf{Reservado} \\
    5 & — & \textbf{Reservado} \\
    6 & — & \textbf{Reservado} \\
    7 & — & \textbf{Reservado} \\
    \hline
    \end{tabular}
    \caption{Banderas del registro ESTADO}
\end{table}

\begin{itemize}
    \item \textbf{\texttt{R4} a \texttt{R31}}: Propósito general.
\end{itemize}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|}
    \hline
    \textbf{Registro} & \textbf{Codificación} \\
    \hline
    \texttt{R0: PC} & 00000 \\
    \texttt{R1: SP} & 00001 \\
    \texttt{R2: IR} & 00010 \\
    \texttt{R3: ESTADO} & 00011 \\
    \texttt{R4} & 00100 \\
    \vdots & \vdots \\
    \texttt{R31} & 11111 \\
    \hline
    \end{tabular}
    \caption{Tabla de registros}
\end{table}

\subsection{Memoria Principal (RAM)}

\begin{itemize}
    \item Se trata de una memoria direccionable de 24 bits, lo que permite un total de:
    \[
    2^{24} = 16,777,216 \, \text{posiciones} = 16 \, \text{MiB de memoria direccionable}
    \]
    \item Cada posición puede almacenar una palabra (8 Bytes).
    \item Está conectada a la Unidad de Servicio mediante los tres buses (datos, direcciones y control).
    \item Toda palabra de memoria contiene 64 bits, tanto para datos como para instrucciones. En caso de datos más pequeños (enteros de 32 bits o 8 bits), se usa alineamiento y enmascaramiento de bits.
    \item Es así que las direcciones de memoria van de:
    \[
    0x000000 \, \text{a} \, 0xFFFFFF
    \]
\end{itemize}

\subsubsection{Espacio reservado para pila}

El computador incluye un \textbf{modelo de pila} gestionado por el registro especial \texttt{SP} (Stack Pointer). La pila es una estructura \textbf{LIFO (Last In, First Out)} utilizada para almacenar temporalmente datos como:

\begin{itemize}
    \item Direcciones de retorno en llamadas a subrutinas (\texttt{CALL}, \texttt{RET})
    \item Registros temporales
    \item Variables locales
\end{itemize}

La pila \textbf{crece hacia direcciones de memoria menores}, es decir, cada operación \texttt{PUSH} decrementa el \texttt{SP}, y cada \texttt{POP} lo incrementa. Las instrucciones \texttt{PUSH Rn} y \texttt{POP Rn} permiten guardar o recuperar el contenido de un registro en la cima de la pila, respectivamente.

\begin{itemize}
    \item Las direcciones van de la 2.031.616 a la 16.777.215 (14.745.599 direcciones)
    \[
    0x1F0000 \, \text{a} \, 0xFFFFFF
    \]
\end{itemize}

\subsubsection{Espacio de datos}

\begin{itemize}
    \item Espacio para datos estáticos o globales.
    \item Es la parte media de la memoria.
    \item Las direcciones van de la 131.072 a la 2.031.615 (1.900.543 direcciones).
    \[
    0x020000 \, \text{a} \, 0x1EFFFF
    \]
\end{itemize}

\subsubsection{Espacio reservado para E/S}

\begin{itemize}
    \item Ver más detalles en la Unidad de Entrada y salida.
    \item Se ubica desde la dirección 65.536 hasta la 131.071 (65.536 direcciones).
    \[
    0x010000 \, \text{a} \, 0x01FFFF
    \]
\end{itemize}

\subsubsection{Espacio reservado para código}

\begin{itemize}
    \item En este espacio se van a guardar las instrucciones.
    \item Este espacio es la parte inferior de la memoria.
    \item Se ubica en la parte baja de la memoria, con direcciones de 0 a 65535 (65.536 direcciones):
    \[
    0x000000 \, \text{a} \, 0x00FFFF
    \]
\end{itemize}


\subsection{Unidad de Entrada y Salida (E/S)}

\begin{itemize}
    \item Administra la interacción con dispositivos periféricos.
    \item Opera tanto para entrada (recepción de datos) como para salida (envío de datos).
    \item Se comunica con la consola.
    \item El computador implementa \textbf{E/S mapeada en memoria (Memory-Mapped I/O)}, es decir, los dispositivos periféricos comparten el mismo espacio de direcciones que la memoria RAM.
    \item Se reserva un rango de direcciones para la comunicación con periféricos conectados a la Unidad de E/S. Esto permite acceder a los dispositivos usando instrucciones estándar, sin necesidad de instrucciones exclusivas de E/S.
\end{itemize}


\subsection{Instrucciones}

Las instrucciones del procesador están codificadas en palabras de 64 bits, siguiendo el formato:

\begin{table}[h!]
    \centering
    \begin{tabular}{|c|c|c|}
    \hline
    \textbf{Campo} & \textbf{Bits} & \textbf{Descripción} \\
    \hline
    \texttt{Opcode} & 6 & Código que determina la operación a ejecutar \\
    \texttt{Registro destino} & 5 & Registro donde se almacenará el resultado \\
    \texttt{Registro base} & 5 & Registro utilizado para direccionamiento base \\
    \texttt{Memoria o Desplazamiento de registro base} & 24 & Offset o dirección absoluta en memoria \\
    \texttt{Extra o valor Inmediato} & 24 & Reservado para ampliación o valores inmediatos \\
    \hline
    \end{tabular}
\end{table}

Este formato se \textbf{reutiliza} para los tres tipos de instrucciones:

\begin{itemize}
    \item \textbf{Tipo I (inmediato / memoria)}: todos los campos son relevantes.
    \item \textbf{Tipo R (entre registros)}: el campo \texttt{Memoria} puede representar un segundo registro o dejarse en cero.
    \item \textbf{Tipo J (salto)}: se usa el campo \texttt{Memoria} como dirección absoluta, y los demás campos se ignoran o se rellenan con ceros.
\end{itemize}

Esta salvedad aplica para todos los casos a no ser que se especifique lo contrario en una instrucción específica.

\subsubsection{Opcodes}

\begin{itemize}
    \item Codificados en 6 bits.
    \item Capacidad para definir \textbf{hasta 64 instrucciones distintas}.
    \item Instrucciones divididas en categorías: aritméticas, lógicas, control de flujo, memoria, E/S.
\end{itemize}


\subsection{Ciclos del Computador}

El ordenador va a pasar por los ciclos de \texttt{fetch-decode-execute}:

\subsubsection{Fetch}

\begin{itemize}
    \item La dirección de la siguiente instrucción se encuentra en el \textbf{PC (\texttt{R0})}.
    \item Se accede a la memoria, se lee la instrucción (64 bits) y se guarda en el \textbf{IR (\texttt{R2})}.
    \item El \texttt{PC} se incrementa en 1.
\end{itemize}

\subsubsection{Decode}

\begin{itemize}
    \item La Unidad de Control extrae el \texttt{opcode}, los registros y los operandos desde el \textbf{IR}.
    \item Determina el tipo de instrucción (I, R, J), identifica la instrucción y prepara el entorno.
\end{itemize}

\subsubsection{Execute}

\begin{itemize}
    \item Según el tipo de instrucción:
    \begin{itemize}
        \item \textbf{Tipo R}: la ALU ejecuta la operación entre registros.
        \item \textbf{Tipo I}: se accede a memoria usando direccionamiento con desplazamiento o directo.
        \item \textbf{Tipo J}: el \texttt{PC} se actualiza con la nueva dirección de salto.
    \end{itemize}
    \item Si aplica, se actualiza el registro \textbf{ESTADO (\texttt{R3})} con los indicadores del resultado.
\end{itemize}


\subsection{Detalles}

\subsubsection{Variables}

Las variables \textbf{globales} se almacenan en el segmento de 
\textbf{datos estáticos}, ubicado entre las direcciones 
\texttt{0x020000} y \texttt{0x1EFFFF}. Estas variables 
existen durante toda la ejecución del programa.

Las variables \textbf{locales}, por el contrario, se 
almacenan dinámicamente en la \textbf{pila}, gestionada por 
el registro \texttt{SP}. Se reservan y liberan mediante 
instrucciones que modifican el puntero de pila, 
y solo existen mientras la subrutina 
correspondiente está en ejecución.

\subsubsection{Tipos de datos}

\textbf{Representación de enteros}

En el computador \textbf{ORISC-I}, los números enteros se representan en formato de \textit{complemento a dos} sobre \textbf{64 bits}. 

Esto permite representar eficientemente tanto enteros positivos como negativos, sin necesidad de un bit de signo separado ni lógica adicional para la ALU.

El \textit{bit más significativo} (MSB, por sus siglas en inglés) indica el signo del número:

\begin{itemize}
    \item Si el MSB es \textbf{0}, el número es \textbf{positivo}.
    \item Si el MSB es \textbf{1}, el número es \textbf{negativo} (en complemento a dos).
\end{itemize}

\textbf{Representación de números en punto flotante}

Para representar números en punto flotante, el computador \textbf{ORISC-I} adopta el estándar \textbf{IEEE 754 de doble precisión} (\textit{64 bits}).

Cada palabra puede codificar un número real con la siguiente estructura:

\begin{itemize}
    \item \textbf{1 bit} de signo.
    \item \textbf{11 bits} para el exponente, con un \textit{sesgo de 1023}.
    \item \textbf{52 bits} para la mantisa (fracción).
\end{itemize}

En versiones futuras, se planea implementar instrucciones especializadas para operaciones aritméticas en coma flotante, tales como:

\texttt{FADD}, \texttt{FSUB}, \texttt{FMUL}, \texttt{FDIV}.

\subsubsection{Manejar valores inmediatos grandes}

Las instrucciones de tipo \textbf{I} permiten cargar \textit{inmediatos} de hasta \textbf{24 bits}.  
Para valores negativos, se realiza automáticamente una \textit{extensión de signo} 
a 64 bits utilizando el formato de \textit{complemento a dos}.

Si se desea cargar valores inmediatos mayores a 24 bits, se propone una 
estrategia extendida basada en dos instrucciones secuenciales:

\begin{itemize}
    \item Una instrucción tipo \texttt{LUI} (\textit{Load Upper Immediate}) carga los bits superiores.
    \item Una instrucción tipo \texttt{ORI} (\textit{OR Immediate}) combina los bits inferiores.
\end{itemize}

Pero en un diseño posterior o si se requiere para extender funcionalidades.



\subsection{Microinstrucciones}

\begin{itemize}
    \item Cada una de 6 bits: Posibilidad de 64 instrucciones
    \item \textbf{R}: es para registros.
    \item \textbf{M}: es para dirección de memoria.
\end{itemize}

\subsubsection{Tipo R: \textbf{entre registros}}

\begin{table}[H]
    \centering
    \begin{tabular}{|p{1.3cm}|p{3cm}|p{1.6cm}|p{5cm}|p{4cm}|}
    \hline
    \textbf{Número} & \textbf{Código Ensamblador} & \textbf{Código Máquina Binario} & \textbf{Instrucción} & \textbf{Descripción} \\
    \hline
    1  & \texttt{SUMA R, R'} & 000001 & Suma dos registros R1 y R2 & Guarda el resultado en R \\
    \hline
    2  & \texttt{RESTA R, R'} & 000010 & Resta dos registros & Guarda el resultado en R \\
    \hline
    3  & \texttt{MULT R, R'} & 000011 & Multiplica dos registros & Guarda el resultado en R \\
    \hline
    4  & \texttt{DIVI R, R'} & 000100 & Divide dos registros (entera) & Guarda el resultado en R \\
    \hline
    5  & \texttt{AND R, R'} & 000101 & Conjunción bit a bit & R ← R \& R' \\
    \hline
    6  & \texttt{OR R, R'} & 000110 & Disyunción bit a bit & R ← R | R' \\
    \hline
    7  & \texttt{XOR R, R'} & 000111 & XOR bit a bit & $R \leftarrow R \oplus R'$ \\
    \hline
    8  & \texttt{NOT R} & 001000 & Negación bit a bit & R ← $\sim$R (inversión de bits) \\
    \hline
    9  & \texttt{COMP R, R'} & 001001 & Compara dos registros (Resta R - R') & Actualiza el registro ESTADO (\texttt{R3}) según el resultado \\
    \hline
    10 & \texttt{MUEV R, R'} & 001010 & Copia el valor de un registro a otro & R ← R' \\
    \hline
    11 & & 001011 & Limpia (pone en cero) un registro & \\
    \hline
    12 & & 001100 & Incrementa un registro en 1 & \\
    \hline
    \end{tabular}
\end{table}

\subsubsection{Tipo I: \textbf{inmediato / memoria}}

\begin{table}[H]
    \centering
    \begin{tabular}{|p{1.3cm}|p{3cm}|p{1.6cm}|p{5cm}|p{4cm}|}
    \hline
    \textbf{Número} & \textbf{Código} & \textbf{Código Máquina Binario} & \textbf{Instrucción} & \textbf{Descripción} \\
    \hline
    13 & \texttt{CARGA R, M} & 001101 & Carga desde memoria a un registro & \\
    \hline
    14 & & 001110 & Guarda el contenido de un registro en memoria & \\
    \hline
    15 & & 001111 & Carga un valor inmediato a un registro & \\
    \hline
    16 & & 010000 & Suma inmediata a un registro & \\
    \hline
    17 & & 010001 & Resta inmediata a un registro & \\
    \hline
    18 & & 010010 & Multiplica un registro por un inmediato & \\
    \hline
    19 & & 010011 & Divide un registro entre un inmediato & \\
    \hline
    20 & & 010100 & AND inmediato & \\
    \hline
    21 & & 010101 & OR inmediato & \\
    \hline
    22 & & 010110 & XOR inmediato & \\
    \hline
    23 & & 010111 & Compara con inmediato y actualiza 0 & \\
    \hline
    24 & & 011000 & Decrementa SP y guarda registro en la pila & \\
    \hline
    25 & & 011001 & Recupera desde pila y carga en registro & \\
    \hline
    26 & & 011010 & No hace nada (instrucción vacía) & \\
    \hline
    \end{tabular}
\end{table}

\subsubsection{Tipo J: \textbf{salto}}

\begin{table}[H]
    \centering
    \begin{tabular}{|p{1.3cm}|p{3cm}|p{1.6cm}|p{5cm}|p{4cm}|}
    \hline
    \textbf{Número} & \textbf{Código} & \textbf{Código Máquina Binario} & \textbf{Instrucción} & \textbf{Descripción} \\
    \hline
    27 & \texttt{SALTA M} & 011011 & Salto incondicional a dirección & \\
    \hline
    28 & & 011100 & Llama a subrutina (guarda PC en la pila y salta) & \\
    \hline
    29 & & 011101 & Vuelve de subrutina (recupera PC desde pila) & \\
    \hline
    30 & & 011110 & Salta si el resultado fue cero (C=1) & \\
    \hline
    31 & & 011111 & Salta si no fue cero (C=0) & \\
    \hline
    32 & & 100000 & Salta si positivo (P=1) & \\
    \hline
    33 & & 100001 & Salta si negativo (N=1) & \\
    \hline
    34 & & 100010 & Salta si overflow (D=1) & \\
    \hline
    35 & & 100011 & Salta si un registro == 0 & \\
    \hline
    36 & & 100100 & Salta si un $\text{registro} \neq 0$ & \\
    \hline
    37 & & 100101 & Salta si mayor $(P = 1 \land C = 0)$ & \\
    \hline
    38 & & 100110 & Salta si menor (N=1) & \\
    \hline
    39 & & 100111 & Detiene la ejecución del programa & \\
    \hline
    40 & & 101000 & Dispara una interrupción por software & \\
    \hline
    \end{tabular}
\end{table}

%---------------------------------------------------------------------------------
% Enlazador Caragador  -----------------------------------------------------------
%---------------------------------------------------------------------------------


\section{Módulo Enlazador-Cargador}

%---------------------------------------------------------------------------------
% Algoritmos de Prueba -----------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Algoritmos de Prueba}

\subsection{Suma de N enteros consecutivos}

Un algoritmo de tipo iterativo que ....

\subsection{Conteo de ceros en un arreglo}

Un algoritmo de secuencial que....

\subsection{Factorial de un número}

Un algoritmo recursivo que ...

%---------------------------------------------------------------------------------
% Referencias -----------------------------------------------------------
%---------------------------------------------------------------------------------


\section{Referencias}
\renewcommand{\refname}{}

\begin{thebibliography}{9}

\bibitem{ref} \label{ref:BPS} M. Bichler, S. Merting, and A. Uzunoglu, 
“Assigning Course Schedules: About Preference Elicitation, Fairness, and Truthfulness,” 
arXiv preprint arXiv:1812.02630, 2018. [En línea]. Disponible en: 
\url{https://arxiv.org/abs/1812.02630}


\end{thebibliography}

\end{document}